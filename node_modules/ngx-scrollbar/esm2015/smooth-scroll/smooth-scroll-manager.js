import { __decorate, __metadata, __param } from "tslib";
import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject, animationFrameScheduler } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./smooth-scroll.model";
// @dynamic
let SmoothScrollManager = class SmoothScrollManager {
    constructor(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = Object.assign({ duration: 468, easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            } }, customDefaultOptions);
    }
    get _w() {
        return this._document.defaultView;
    }
    /**
     * Timing method
     */
    get _now() {
        return this._w.performance && this._w.performance.now
            ? this._w.performance.now.bind(this._w.performance)
            : Date.now;
    }
    /**
     * changes scroll position inside an element
     */
    _scrollElement(el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    }
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    _getElement(el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    }
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    _initSmoothScroll(el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    }
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    _isFinished(context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    }
    /**
     * Terminates an ongoing smooth scroll
     */
    _interrupted(el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    }
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    _destroy(el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    }
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    _step(context) {
        return new Observable((subscriber) => {
            let elapsed = (this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            const value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule(() => subscriber.next(context));
        });
    }
    _applyScrollToOptions(el, options) {
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        const destroyed = this._initSmoothScroll(el);
        const context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(resolve => {
            // Scroll each step recursively
            of(null).pipe(expand(() => this._step(context).pipe(takeWhile((currContext) => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();
        });
    }
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    scrollTo(scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            const el = this._getElement(scrollable);
            const isRtl = getComputedStyle(el).direction === 'rtl';
            const rtlScrollAxisType = getRtlScrollAxisType();
            const options = Object.assign(Object.assign(Object.assign({}, this._defaultOptions), customOptions), {
                // Rewrite start & end offsets as right or left offsets.
                left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
            });
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== 0 /* NORMAL */) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === 2 /* INVERTED */) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === 1 /* NEGATED */) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    }
    /**
     * Scroll to element by reference or selector
     */
    scrollToElement(scrollable, target, customOptions) {
        const scrollableEl = this._getElement(scrollable);
        const targetEl = this._getElement(target, scrollableEl);
        const options = Object.assign(Object.assign({}, customOptions), {
            left: targetEl.offsetLeft + (customOptions.left || 0),
            top: targetEl.offsetTop + (customOptions.top || 0)
        });
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    }
};
SmoothScrollManager.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
];
SmoothScrollManager.ɵprov = i0.ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i2.SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
SmoothScrollManager = __decorate([
    Injectable({
        providedIn: 'root'
    }),
    __param(0, Inject(DOCUMENT)),
    __param(1, Inject(PLATFORM_ID)),
    __param(2, Optional()), __param(2, Inject(SMOOTH_SCROLL_OPTIONS)),
    __metadata("design:paramtypes", [Object, Object, Object])
], SmoothScrollManager);
export { SmoothScrollManager };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsLyIsInNvdXJjZXMiOlsic21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQWMsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RGLE9BQU8sRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUFFLG9CQUFvQixFQUFxQixNQUFNLHVCQUF1QixDQUFDO0FBRWhGLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFjLHVCQUF1QixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RHLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUUsT0FBTyxZQUFZLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFDTCxxQkFBcUIsRUFLdEIsTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUUvQixXQUFXO0FBSVgsSUFBYSxtQkFBbUIsR0FBaEMsTUFBYSxtQkFBbUI7SUF3QjlCLFlBQXNDLFNBQWMsRUFDWCxTQUFpQixFQUNILG9CQUEyQztRQUY1RCxjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQ1gsY0FBUyxHQUFULFNBQVMsQ0FBUTtRQXBCMUQsbUdBQW1HO1FBQ25HLG1HQUFtRztRQUNuRyxvR0FBb0c7UUFDcEcscURBQXFEO1FBQzdDLG9CQUFlLEdBQUcsSUFBSSxHQUFHLEVBQThCLENBQUM7UUFrQjlELElBQUksQ0FBQyxlQUFlLG1CQUNsQixRQUFRLEVBQUUsR0FB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RCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQztRQUN4RCxNQUFNLE9BQU8sbUNBQ1IsYUFBYSxHQUNiO1lBQ0QsSUFBSSxFQUFFLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztZQUNyRCxHQUFHLEVBQUUsUUFBUSxDQUFDLFNBQVMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ25ELENBQ0YsQ0FBQztRQUNGLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzdFLENBQUM7Q0FDRixDQUFBOzs0Q0FuTWMsTUFBTSxTQUFDLFFBQVE7eUNBQ2YsTUFBTSxTQUFDLFdBQVc7NENBQ2xCLFFBQVEsWUFBSSxNQUFNLFNBQUMscUJBQXFCOzs7QUExQjFDLG1CQUFtQjtJQUgvQixVQUFVLENBQUM7UUFDVixVQUFVLEVBQUUsTUFBTTtLQUNuQixDQUFDO0lBeUJhLFdBQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFBO0lBQ2hCLFdBQUEsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFBO0lBQ25CLFdBQUEsUUFBUSxFQUFFLENBQUEsRUFBRSxXQUFBLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxDQUFBOztHQTFCM0MsbUJBQW1CLENBMk4vQjtTQTNOWSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQsIGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IGNvZXJjZUVsZW1lbnQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgZ2V0UnRsU2Nyb2xsQXhpc1R5cGUsIFJ0bFNjcm9sbEF4aXNUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IF9Cb3R0b20sIF9MZWZ0LCBfUmlnaHQsIF9Ub3AsIF9XaXRob3V0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3Njcm9sbGluZyc7XG5pbXBvcnQgeyBmcm9tRXZlbnQsIG1lcmdlLCBvZiwgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaWJlciwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGV4cGFuZCwgZmluYWxpemUsIHRha2UsIHRha2VVbnRpbCwgdGFrZVdoaWxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IEJlemllckVhc2luZyBmcm9tICdiZXppZXItZWFzaW5nJztcbmltcG9ydCB7XG4gIFNNT09USF9TQ1JPTExfT1BUSU9OUyxcbiAgU21vb3RoU2Nyb2xsRWxlbWVudCxcbiAgU21vb3RoU2Nyb2xsT3B0aW9ucyxcbiAgU21vb3RoU2Nyb2xsU3RlcCxcbiAgU21vb3RoU2Nyb2xsVG9PcHRpb25zXG59IGZyb20gJy4vc21vb3RoLXNjcm9sbC5tb2RlbCc7XG5cbi8vIEBkeW5hbWljXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBTbW9vdGhTY3JvbGxNYW5hZ2VyIHtcblxuICAvLyBEZWZhdWx0IG9wdGlvbnNcbiAgcHJpdmF0ZSByZWFkb25seSBfZGVmYXVsdE9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucztcblxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgb25nb2luZyBTbW9vdGhTY3JvbGwgZnVuY3Rpb25zIHNvIHRoZXkgY2FuIGJlIGhhbmRsZWQgaW4gY2FzZSBvZiBkdXBsaWNhdGlvbi5cbiAgLy8gRWFjaCBzY3JvbGxlZCBlbGVtZW50IGdldHMgYSBkZXN0cm95ZXIgc3RyZWFtIHdoaWNoIGdldHMgZGVsZXRlZCBpbW1lZGlhdGVseSBhZnRlciBpdCBjb21wbGV0ZXMuXG4gIC8vIFB1cnBvc2U6IElmIHVzZXIgY2FsbGVkIGEgc2Nyb2xsIGZ1bmN0aW9uIGFnYWluIG9uIHRoZSBzYW1lIGVsZW1lbnQgYmVmb3JlIHRoZSBzY3JvbGxzIGNvbXBsZXRlcyxcbiAgLy8gaXQgY2FuY2VscyB0aGUgb25nb2luZyBzY3JvbGwgYW5kIHN0YXJ0cyBhIG5ldyBvbmVcbiAgcHJpdmF0ZSBfb25Hb2luZ1Njcm9sbHMgPSBuZXcgTWFwPEhUTUxFbGVtZW50LCBTdWJqZWN0PHZvaWQ+PigpO1xuXG4gIHByaXZhdGUgZ2V0IF93KCk6IGFueSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB9XG5cbiAgLyoqXG4gICAqIFRpbWluZyBtZXRob2RcbiAgICovXG4gIHByaXZhdGUgZ2V0IF9ub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuX3cucGVyZm9ybWFuY2UgJiYgdGhpcy5fdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgID8gdGhpcy5fdy5wZXJmb3JtYW5jZS5ub3cuYmluZCh0aGlzLl93LnBlcmZvcm1hbmNlKVxuICAgICAgOiBEYXRlLm5vdztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXG4gICAgICAgICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtOiBvYmplY3QsXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoU01PT1RIX1NDUk9MTF9PUFRJT05TKSBjdXN0b21EZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKSB7XG4gICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBkdXJhdGlvbjogNDY4LFxuICAgICAgZWFzaW5nOiB7XG4gICAgICAgIHgxOiAwLjQyLFxuICAgICAgICB5MTogMCxcbiAgICAgICAgeDI6IDAuNTgsXG4gICAgICAgIHkyOiAxXG4gICAgICB9LFxuICAgICAgLi4uY3VzdG9tRGVmYXVsdE9wdGlvbnMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjaGFuZ2VzIHNjcm9sbCBwb3NpdGlvbiBpbnNpZGUgYW4gZWxlbWVudFxuICAgKi9cbiAgcHJpdmF0ZSBfc2Nyb2xsRWxlbWVudChlbDogSFRNTEVsZW1lbnQsIHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XG4gICAgZWwuc2Nyb2xsTGVmdCA9IHg7XG4gICAgZWwuc2Nyb2xsVG9wID0geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgZ2l2ZW4gcGFyYW1ldGVyIG9mIHR5cGUgSFRNTEVsZW1lbnQsIEVsZW1lbnRSZWYgb3Igc2VsZWN0b3JcbiAgICovXG4gIHByaXZhdGUgX2dldEVsZW1lbnQoZWw6IEhUTUxFbGVtZW50IHwgRWxlbWVudFJlZiB8IHN0cmluZywgcGFyZW50PzogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiAocGFyZW50IHx8IHRoaXMuX2RvY3VtZW50KS5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZXJjZUVsZW1lbnQ8SFRNTEVsZW1lbnQ+KGVsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIGRlc3Ryb3llciBzdHJlYW0sIHJlLWluaXRpYWxpemVzIGl0IGlmIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgc2Nyb2xsZWRcbiAgICovXG4gIHByaXZhdGUgX2luaXRTbW9vdGhTY3JvbGwoZWw6IEhUTUxFbGVtZW50KTogU3ViamVjdDx2b2lkPiB7XG4gICAgaWYgKHRoaXMuX29uR29pbmdTY3JvbGxzLmhhcyhlbCkpIHtcbiAgICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmdldChlbCkhLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX29uR29pbmdTY3JvbGxzLnNldChlbCwgbmV3IFN1YmplY3Q8dm9pZD4oKSkhLmdldChlbCkhO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBzbW9vdGggc2Nyb2xsIGhhcyByZWFjaGVkLCBjbGVhbnMgdXAgdGhlIHNtb290aCBzY3JvbGwgc3RyZWFtIGFuZCByZXNvbHZlcyBpdHMgcHJvbWlzZVxuICAgKi9cbiAgcHJpdmF0ZSBfaXNGaW5pc2hlZChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwLCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4sIHJlc29sdmU6ICgpID0+IHZvaWQpOiBib29sZWFuIHtcbiAgICBpZiAoY29udGV4dC5jdXJyZW50WCAhPT0gY29udGV4dC54IHx8IGNvbnRleHQuY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRlc3Ryb3llZC5uZXh0KCk7XG4gICAgcmVzb2x2ZSgpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXJtaW5hdGVzIGFuIG9uZ29pbmcgc21vb3RoIHNjcm9sbFxuICAgKi9cbiAgcHJpdmF0ZSBfaW50ZXJydXB0ZWQoZWw6IEhUTUxFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiBtZXJnZShcbiAgICAgIGZyb21FdmVudChlbCwgJ3doZWVsJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxuICAgICAgZnJvbUV2ZW50KGVsLCAndG91Y2htb3ZlJywgeyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pLFxuICAgICAgZGVzdHJveWVkXG4gICAgKS5waXBlKHRha2UoMSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIGRlc3Ryb3llciBmdW5jdGlvbiwgcnVucyBpZiB0aGUgc21vb3RoIHNjcm9sbCBoYXMgZmluaXNoZWQgb3IgaW50ZXJydXB0ZWRcbiAgICovXG4gIHByaXZhdGUgX2Rlc3Ryb3koZWw6IEhUTUxFbGVtZW50LCBkZXN0cm95ZWQ6IFN1YmplY3Q8dm9pZD4pOiB2b2lkIHtcbiAgICBkZXN0cm95ZWQuY29tcGxldGUoKTtcbiAgICB0aGlzLl9vbkdvaW5nU2Nyb2xscy5kZWxldGUoZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gY2FsbGVkIHJlY3Vyc2l2ZWx5IHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICovXG4gIHByaXZhdGUgX3N0ZXAoY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCk6IE9ic2VydmFibGU8U21vb3RoU2Nyb2xsU3RlcD4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxTbW9vdGhTY3JvbGxTdGVwPikgPT4ge1xuICAgICAgbGV0IGVsYXBzZWQgPSAodGhpcy5fbm93KCkgLSBjb250ZXh0LnN0YXJ0VGltZSkgLyBjb250ZXh0LmR1cmF0aW9uO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5lYXNpbmcoZWxhcHNlZCk7XG5cbiAgICAgIGNvbnRleHQuY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGNvbnRleHQuY3VycmVudFkgPSBjb250ZXh0LnN0YXJ0WSArIChjb250ZXh0LnkgLSBjb250ZXh0LnN0YXJ0WSkgKiB2YWx1ZTtcblxuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChjb250ZXh0LnNjcm9sbGFibGUsIGNvbnRleHQuY3VycmVudFgsIGNvbnRleHQuY3VycmVudFkpO1xuICAgICAgLy8gUHJvY2VlZCB0byB0aGUgc3RlcFxuICAgICAgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIuc2NoZWR1bGUoKCkgPT4gc3Vic2NyaWJlci5uZXh0KGNvbnRleHQpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsOiBIVE1MRWxlbWVudCwgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCFvcHRpb25zLmR1cmF0aW9uISkge1xuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudChlbCwgb3B0aW9ucyEubGVmdCEsIG9wdGlvbnMhLnRvcCEpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgYSBkZXN0cm95ZXIgc3RyZWFtLCByZWluaXRpYWxpemUgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxuICAgIGNvbnN0IGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IHRoaXMuX2luaXRTbW9vdGhTY3JvbGwoZWwpO1xuXG4gICAgY29uc3QgY29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCA9IHtcbiAgICAgIHNjcm9sbGFibGU6IGVsLFxuICAgICAgc3RhcnRUaW1lOiB0aGlzLl9ub3coKSxcbiAgICAgIHN0YXJ0WDogZWwuc2Nyb2xsTGVmdCxcbiAgICAgIHN0YXJ0WTogZWwuc2Nyb2xsVG9wLFxuICAgICAgeDogb3B0aW9ucy5sZWZ0ID09IG51bGwgPyBlbC5zY3JvbGxMZWZ0IDogfn5vcHRpb25zLmxlZnQsXG4gICAgICB5OiBvcHRpb25zLnRvcCA9PSBudWxsID8gZWwuc2Nyb2xsVG9wIDogfn5vcHRpb25zLnRvcCxcbiAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uISxcbiAgICAgIGVhc2luZzogQmV6aWVyRWFzaW5nKG9wdGlvbnMuZWFzaW5nIS54MSEsIG9wdGlvbnMuZWFzaW5nIS55MSEsIG9wdGlvbnMuZWFzaW5nIS54MiEsIG9wdGlvbnMuZWFzaW5nIS55MiEpXG4gICAgfTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIC8vIFNjcm9sbCBlYWNoIHN0ZXAgcmVjdXJzaXZlbHlcbiAgICAgIG9mKG51bGwpLnBpcGUoXG4gICAgICAgIGV4cGFuZCgoKSA9PiB0aGlzLl9zdGVwKGNvbnRleHQpLnBpcGUoXG4gICAgICAgICAgdGFrZVdoaWxlKChjdXJyQ29udGV4dDogU21vb3RoU2Nyb2xsU3RlcCkgPT4gdGhpcy5faXNGaW5pc2hlZChjdXJyQ29udGV4dCwgZGVzdHJveWVkLCByZXNvbHZlKSlcbiAgICAgICAgKSksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLl9pbnRlcnJ1cHRlZChlbCwgZGVzdHJveWVkKSksXG4gICAgICAgIGZpbmFsaXplKCgpID0+IHRoaXMuX2Rlc3Ryb3koZWwsIGRlc3Ryb3llZCkpXG4gICAgICApLnN1YnNjcmliZSgpO1xuICAgIH0pO1xuICB9XG5cblxuICAvKipcbiAgICogU2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIG9mZnNldHMuIFRoaXMgaXMgYSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIGJyb3dzZXIncyBuYXRpdmUgc2Nyb2xsVG9cbiAgICogbWV0aG9kLCBzaW5jZSBicm93c2VycyBhcmUgbm90IGNvbnNpc3RlbnQgYWJvdXQgd2hhdCBzY3JvbGxMZWZ0IG1lYW5zIGluIFJUTC4gRm9yIHRoaXMgbWV0aG9kXG4gICAqIGxlZnQgYW5kIHJpZ2h0IGFsd2F5cyByZWZlciB0byB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgc2Nyb2xsaW5nIGNvbnRhaW5lciBpcnJlc3BlY3RpdmVcbiAgICogb2YgdGhlIGxheW91dCBkaXJlY3Rpb24uIHN0YXJ0IGFuZCBlbmQgcmVmZXIgdG8gbGVmdCBhbmQgcmlnaHQgaW4gYW4gTFRSIGNvbnRleHQgYW5kIHZpY2UtdmVyc2FcbiAgICogaW4gYW4gUlRMIGNvbnRleHQuXG4gICAqIEBwYXJhbSBzY3JvbGxhYmxlIGVsZW1lbnRcbiAgICogQHBhcmFtIGN1c3RvbU9wdGlvbnMgc3BlY2lmaWVkIHRoZSBvZmZzZXRzIHRvIHNjcm9sbCB0by5cbiAgICovXG4gIHNjcm9sbFRvKHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIGN1c3RvbU9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybSkpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcbiAgICAgIGNvbnN0IGlzUnRsID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICAgIGNvbnN0IHJ0bFNjcm9sbEF4aXNUeXBlID0gZ2V0UnRsU2Nyb2xsQXhpc1R5cGUoKTtcblxuICAgICAgY29uc3Qgb3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zID0ge1xuICAgICAgICAuLi4odGhpcy5fZGVmYXVsdE9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbSAmIF9Ub3A+KSxcbiAgICAgICAgLi4uY3VzdG9tT3B0aW9ucyxcbiAgICAgICAgLi4uKHtcbiAgICAgICAgICAvLyBSZXdyaXRlIHN0YXJ0ICYgZW5kIG9mZnNldHMgYXMgcmlnaHQgb3IgbGVmdCBvZmZzZXRzLlxuICAgICAgICAgIGxlZnQ6IGN1c3RvbU9wdGlvbnMubGVmdCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5lbmQgOiBjdXN0b21PcHRpb25zLnN0YXJ0KSA6IGN1c3RvbU9wdGlvbnMubGVmdCxcbiAgICAgICAgICByaWdodDogY3VzdG9tT3B0aW9ucy5yaWdodCA9PSBudWxsID8gKGlzUnRsID8gY3VzdG9tT3B0aW9ucy5zdGFydCA6IGN1c3RvbU9wdGlvbnMuZW5kKSA6IGN1c3RvbU9wdGlvbnMucmlnaHRcbiAgICAgICAgfSBhcyBfV2l0aG91dDxfQm90dG9tICYgX1RvcD4pXG4gICAgICB9O1xuXG4gICAgICAvLyBSZXdyaXRlIHRoZSBib3R0b20gb2Zmc2V0IGFzIGEgdG9wIG9mZnNldC5cbiAgICAgIGlmIChvcHRpb25zLmJvdHRvbSAhPSBudWxsKSB7XG4gICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9Cb3R0b20+ICYgX1RvcCkudG9wID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0IC0gb3B0aW9ucy5ib3R0b207XG4gICAgICB9XG5cbiAgICAgIC8vIFJld3JpdGUgdGhlIHJpZ2h0IG9mZnNldCBhcyBhIGxlZnQgb2Zmc2V0LlxuICAgICAgaWYgKGlzUnRsICYmIHJ0bFNjcm9sbEF4aXNUeXBlICE9PSBSdGxTY3JvbGxBeGlzVHlwZS5OT1JNQUwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0xlZnQ+ICYgX1JpZ2h0KS5yaWdodCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLmxlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xuICAgICAgICAgIG9wdGlvbnMubGVmdCA9IG9wdGlvbnMucmlnaHQgPyAtb3B0aW9ucy5yaWdodCA6IG9wdGlvbnMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfUmlnaHQ+ICYgX0xlZnQpLmxlZnQgPSBlbC5zY3JvbGxXaWR0aCAtIGVsLmNsaWVudFdpZHRoIC0gb3B0aW9ucy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5U2Nyb2xsVG9PcHRpb25zKGVsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbCB0byBlbGVtZW50IGJ5IHJlZmVyZW5jZSBvciBzZWxlY3RvclxuICAgKi9cbiAgc2Nyb2xsVG9FbGVtZW50KHNjcm9sbGFibGU6IFNtb290aFNjcm9sbEVsZW1lbnQsIHRhcmdldDogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsT3B0aW9ucyAmIF9Ub3AgJiBfTGVmdCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNjcm9sbGFibGVFbCA9IHRoaXMuX2dldEVsZW1lbnQoc2Nyb2xsYWJsZSk7XG4gICAgY29uc3QgdGFyZ2V0RWwgPSB0aGlzLl9nZXRFbGVtZW50KHRhcmdldCwgc2Nyb2xsYWJsZUVsKTtcbiAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XG4gICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgLi4ue1xuICAgICAgICBsZWZ0OiB0YXJnZXRFbC5vZmZzZXRMZWZ0ICsgKGN1c3RvbU9wdGlvbnMubGVmdCB8fCAwKSxcbiAgICAgICAgdG9wOiB0YXJnZXRFbC5vZmZzZXRUb3AgKyAoY3VzdG9tT3B0aW9ucy50b3AgfHwgMClcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0YXJnZXRFbCA/IHRoaXMuc2Nyb2xsVG8oc2Nyb2xsYWJsZUVsLCBvcHRpb25zKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG59XG4iXX0=