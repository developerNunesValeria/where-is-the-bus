import { __decorate, __metadata, __param } from "tslib";
import { Directive, Optional, Input, Output, OnInit, OnDestroy, NgZone } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { Observable, Subject, Subscription } from 'rxjs';
import { filter, map, tap, distinctUntilChanged } from 'rxjs/operators';
import { NgScrollbar } from 'ngx-scrollbar';
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if it scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
}
__decorate([
    Input('reachedOffset'),
    __metadata("design:type", Object)
], ScrollReached.prototype, "offset", void 0);
let VerticalScrollReached = class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
};
VerticalScrollReached = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], VerticalScrollReached);
let HorizontalScrollReached = class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
};
HorizontalScrollReached = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], HorizontalScrollReached);
let NgScrollbarReachedTop = class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
};
NgScrollbarReachedTop.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedTop.prototype, "reachedTop", void 0);
NgScrollbarReachedTop = __decorate([
    Directive({
        selector: '[reachedTop], [reached-top]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], NgScrollbarReachedTop);
export { NgScrollbarReachedTop };
let NgScrollbarReachedBottom = class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
};
NgScrollbarReachedBottom.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedBottom.prototype, "reachedBottom", void 0);
NgScrollbarReachedBottom = __decorate([
    Directive({
        selector: '[reachedBottom], [reached-bottom]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], NgScrollbarReachedBottom);
export { NgScrollbarReachedBottom };
let NgScrollbarReachedStart = class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
};
NgScrollbarReachedStart.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedStart.prototype, "reachedStart", void 0);
NgScrollbarReachedStart = __decorate([
    Directive({
        selector: '[reachedStart], [reached-start]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
], NgScrollbarReachedStart);
export { NgScrollbarReachedStart };
let NgScrollbarReachedEnd = class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
};
NgScrollbarReachedEnd.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedEnd.prototype, "reachedEnd", void 0);
NgScrollbarReachedEnd = __decorate([
    Directive({
        selector: '[reachedEnd], [reached-end]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
], NgScrollbarReachedEnd);
export { NgScrollbarReachedEnd };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLXJlYWNoZWQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtc2Nyb2xsYmFyL3JlYWNoZWQtZXZlbnQvIiwic291cmNlcyI6WyJuZy1zY3JvbGxiYXItcmVhY2hlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFbkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUMsbURBQW1EO0FBQ25ELHNEQUFzRDtBQUV0RCxNQUFNLGdCQUFnQjtJQUNwQixNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWMsRUFBRSxDQUFNO1FBQ3RDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQWMsRUFBRSxDQUFNO1FBQ3pDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdHLENBQUM7SUFFRCxNQUFNLENBQUMsWUFBWSxDQUFDLE1BQWMsRUFBRSxDQUFNLEVBQUUs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LENBQWE7UUFBWSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQVUsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7UUFIN0csd0RBQXdEO1FBQzlDLGVBQVUsR0FBb0IsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUkxRCxDQUFDO0lBRUQsUUFBUTtRQUNOLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLE9BQU8sQ0FBQyxNQUFjLEVBQUUsQ0FBTTtRQUN0QyxPQUFPLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDMUcsQ0FBQztDQUNGLENBQUE7O1lBaEI4QyxXQUFXLHVCQUEzQyxRQUFRO1lBQXFELE1BQU07WUFBZSxjQUFjOztBQUZuRztJQUFULE1BQU0sRUFBRTs4QkFBYSxVQUFVO3lEQUEwQjtBQUgvQyxxQkFBcUI7SUFIakMsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLDZCQUE2QjtLQUN4QyxDQUFDO0lBTWEsV0FBQSxRQUFRLEVBQUUsQ0FBQTtxQ0FBc0IsV0FBVyxFQUFrQixNQUFNLEVBQWUsY0FBYztHQUxsRyxxQkFBcUIsQ0FxQmpDO1NBckJZLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgT3B0aW9uYWwsIElucHV0LCBPdXRwdXQsIE9uSW5pdCwgT25EZXN0cm95LCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgUnRsU2Nyb2xsQXhpc1R5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9uLCBTdWJzY3JpYmVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIG1hcCwgdGFwLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5nU2Nyb2xsYmFyIH0gZnJvbSAnbmd4LXNjcm9sbGJhcic7XG4vLyBVbmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lIGluIGRldmVsb3BtZW50IG1vZGVcbi8vIGltcG9ydCB7IE5nU2Nyb2xsYmFyIH0gZnJvbSAnLi4vLi4vc3JjL3B1YmxpYy1hcGknO1xuXG5jbGFzcyBSZWFjaGVkRnVuY3Rpb25zIHtcbiAgc3RhdGljIHJlYWNoZWRUb3Aob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbFRvcCwgMCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHN0YXRpYyByZWFjaGVkQm90dG9tKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbFRvcCArIGUudGFyZ2V0LmNsaWVudEhlaWdodCwgZS50YXJnZXQuc2Nyb2xsSGVpZ2h0LCBvZmZzZXQpO1xuICB9XG5cbiAgc3RhdGljIHJlYWNoZWRTdGFydChvZmZzZXQ6IG51bWJlciwgZTogYW55LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQpIHtcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZChlLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5JTlZFUlRFRCkge1xuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZChlLnRhcmdldC5zY3JvbGxMZWZ0ICsgZS50YXJnZXQuY2xpZW50V2lkdGgsIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xuICB9XG5cbiAgc3RhdGljIHJlYWNoZWRFbmQob2Zmc2V0OiBudW1iZXIsIGU6IGFueSwgZGlyZWN0aW9uOiAnbHRyJyB8ICdydGwnLCBydGxTY3JvbGxBeGlzVHlwZTogUnRsU2Nyb2xsQXhpc1R5cGUpOiBib29sZWFuIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XG4gICAgICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLShlLnRhcmdldC5zY3JvbGxMZWZ0IC0gZS50YXJnZXQuY2xpZW50V2lkdGgpLCBlLnRhcmdldC5zY3JvbGxXaWR0aCwgb2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtKGUudGFyZ2V0LnNjcm9sbExlZnQgKyBlLnRhcmdldC5jbGllbnRXaWR0aCksIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtZS50YXJnZXQuc2Nyb2xsTGVmdCwgMCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZChlLnRhcmdldC5zY3JvbGxMZWZ0ICsgZS50YXJnZXQuY2xpZW50V2lkdGgsIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xuICB9XG5cbiAgc3RhdGljIHJlYWNoZWQoY3VyclBvc2l0aW9uOiBudW1iZXIsIHRhcmdldFBvc2l0aW9uOiBudW1iZXIsIG9mZnNldDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGN1cnJQb3NpdGlvbiA+PSB0YXJnZXRQb3NpdGlvbiAtIG9mZnNldDtcbiAgfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAvKiogb2Zmc2V0OiBSZWFjaGVkIG9mZnNldCB2YWx1ZSBpbiBweCAqL1xuICBASW5wdXQoJ3JlYWNoZWRPZmZzZXQnKSBvZmZzZXQgPSAwO1xuXG4gIC8qKlxuICAgKiBTdHJlYW0gdGhhdCBlbWl0cyBzY3JvbGwgZXZlbnQgd2hlbiBgTmdTY3JvbGxiYXIuc2Nyb2xsZWRgIGlzIGluaXRpYWxpemVkLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBzdWJqZWN0IGlzIHVzZWQgdG8gaG9sZCB0aGUgcGxhY2Ugb2YgYE5nU2Nyb2xsYmFyLnNjcm9sbGVkYCB3aGVuIGl0J3Mgbm90IGluaXRpYWxpemVkIHlldFxuICAgKi9cbiAgcHJvdGVjdGVkIHNjcm9sbEV2ZW50ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gIC8qKiBzdWJzY3JpcHRpb246IFNjcm9sbGVkIGV2ZW50IHN1YnNjcmlwdGlvbiwgdXNlZCB0byB1bnN1YnNjcmliZSBmcm9tIHRoZSBldmVudCBvbiBkZXN0cm95ICovXG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG5cbiAgLyoqIEEgc3RyZWFtIHVzZWQgdG8gYXNzaWduIHRoZSByZWFjaGVkIG91dHB1dCAqL1xuICBwcm90ZWN0ZWQgcmVhY2hlZEV2ZW50ID0gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8YW55PikgPT5cbiAgICB0aGlzLnNjcm9sbFJlYWNoZWQoKS5zdWJzY3JpYmUoXyA9PlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnpvbmUucnVuKCgpID0+IHN1YnNjcmliZXIubmV4dChfKSkpKSk7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lKSB7XG4gICAgaWYgKCFzY3JvbGxiYXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW05nU2Nyb2xsYmFyUmVhY2hlZCBEaXJlY3RpdmVdOiBIb3N0IGVsZW1lbnQgbXVzdCBiZSBhbiBOZ1Njcm9sbGJhciBjb21wb25lbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBzY3JvbGxSZWFjaGVkKCk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgLy8gY3VycmVudCBldmVudFxuICAgIGxldCBjdXJyRXZlbnQ6IGFueTtcblxuICAgIHJldHVybiB0aGlzLnNjcm9sbEV2ZW50LnBpcGUoXG4gICAgICB0YXAoKGUpID0+IGN1cnJFdmVudCA9IGUpLFxuICAgICAgLy8gQ2hlY2sgaWYgaXQgc2Nyb2xsIGhhcyByZWFjaGVkXG4gICAgICBtYXAoKGUpID0+IHRoaXMucmVhY2hlZCh0aGlzLm9mZnNldCwgZSkpLFxuICAgICAgLy8gRGlzdGluY3QgdW50aWwgcmVhY2hlZCB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIC8vIEVtaXQgb25seSBpZiByZWFjaGVkIGlzIHRydWVcbiAgICAgIGZpbHRlcigocmVhY2hlZDogYm9vbGVhbikgPT4gcmVhY2hlZCksXG4gICAgICAvLyBSZXR1cm4gc2Nyb2xsIGV2ZW50XG4gICAgICBtYXAoKCkgPT4gY3VyckV2ZW50KVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZT86IGFueSk6IGJvb2xlYW47XG59XG5cbmFic3RyYWN0IGNsYXNzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbGJhci52ZXJ0aWNhbFNjcm9sbGVkLnN1YnNjcmliZSh0aGlzLnNjcm9sbEV2ZW50KTtcbiAgfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBleHRlbmRzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnNjcm9sbGJhci5ob3Jpem9udGFsU2Nyb2xsZWQuc3Vic2NyaWJlKHRoaXMuc2Nyb2xsRXZlbnQpO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tyZWFjaGVkVG9wXSwgW3JlYWNoZWQtdG9wXScsXG59KVxuZXhwb3J0IGNsYXNzIE5nU2Nyb2xsYmFyUmVhY2hlZFRvcCBleHRlbmRzIFZlcnRpY2FsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSB0b3AgKi9cbiAgQE91dHB1dCgpIHJlYWNoZWRUb3A6IE9ic2VydmFibGU8YW55PiA9IHRoaXMucmVhY2hlZEV2ZW50O1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lKSB7XG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSB0b3AgKHZlcnRpY2FsbHkpXG4gICAqIEBwYXJhbSBvZmZzZXQgU2Nyb2xsIG9mZnNldFxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcbiAgICovXG4gIHByb3RlY3RlZCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkVG9wKG9mZnNldCwgZSk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3JlYWNoZWRCb3R0b21dLCBbcmVhY2hlZC1ib3R0b21dJyxcbn0pXG5leHBvcnQgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkQm90dG9tIGV4dGVuZHMgVmVydGljYWxTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGJvdHRvbSAqL1xuICBAT3V0cHV0KCkgcmVhY2hlZEJvdHRvbTogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5yZWFjaGVkRXZlbnQ7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGJvdHRvbSAodmVydGljYWxseSlcbiAgICogQHBhcmFtIG9mZnNldCBTY3JvbGwgb2Zmc2V0XG4gICAqIEBwYXJhbSBlIFNjcm9sbCBldmVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWNoZWQob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWRCb3R0b20ob2Zmc2V0LCBlKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcmVhY2hlZFN0YXJ0XSwgW3JlYWNoZWQtc3RhcnRdJyxcbn0pXG5leHBvcnQgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkU3RhcnQgZXh0ZW5kcyBIb3Jpem9udGFsU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBzdGFydCAqL1xuICBAT3V0cHV0KCkgcmVhY2hlZFN0YXJ0OiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSwgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5KSB7XG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBzdGFydCAoaG9yaXpvbnRhbGx5KVxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcbiAgICogQHBhcmFtIGUgU2Nyb2xsIGV2ZW50XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZFN0YXJ0KG9mZnNldCwgZSwgdGhpcy5kaXIudmFsdWUsIHRoaXMuc2Nyb2xsYmFyLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUpO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tyZWFjaGVkRW5kXSwgW3JlYWNoZWQtZW5kXScsXG59KVxuZXhwb3J0IGNsYXNzIE5nU2Nyb2xsYmFyUmVhY2hlZEVuZCBleHRlbmRzIEhvcml6b250YWxTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIGVuZCAqL1xuICBAT3V0cHV0KCkgcmVhY2hlZEVuZDogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5yZWFjaGVkRXZlbnQ7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUsIHByaXZhdGUgZGlyOiBEaXJlY3Rpb25hbGl0eSkge1xuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgZW5kIChob3Jpem9udGFsbHkpXG4gICAqIEBwYXJhbSBvZmZzZXQgU2Nyb2xsIG9mZnNldFxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcbiAgICovXG4gIHByb3RlY3RlZCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkRW5kKG9mZnNldCwgZSwgdGhpcy5kaXIudmFsdWUsIHRoaXMuc2Nyb2xsYmFyLm1hbmFnZXIucnRsU2Nyb2xsQXhpc1R5cGUpO1xuICB9XG59XG4iXX0=