import { __decorate, __extends, __metadata, __param } from "tslib";
import { Directive, Optional, Input, Output, OnInit, OnDestroy, NgZone } from '@angular/core';
import { Directionality } from '@angular/cdk/bidi';
import { Observable, Subject, Subscription } from 'rxjs';
import { filter, map, tap, distinctUntilChanged } from 'rxjs/operators';
import { NgScrollbar } from 'ngx-scrollbar';
// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
var ReachedFunctions = /** @class */ (function () {
    function ReachedFunctions() {
    }
    ReachedFunctions.reachedTop = function (offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    };
    ReachedFunctions.reachedBottom = function (offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    };
    ReachedFunctions.reachedStart = function (offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    };
    ReachedFunctions.reachedEnd = function (offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    };
    ReachedFunctions.reached = function (currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    };
    return ReachedFunctions;
}());
var ScrollReached = /** @class */ (function () {
    function ScrollReached(scrollbar, zone) {
        var _this = this;
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable(function (subscriber) {
            return _this.scrollReached().subscribe(function (_) {
                return Promise.resolve().then(function () { return _this.zone.run(function () { return subscriber.next(_); }); });
            });
        });
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ScrollReached.prototype.ngOnDestroy = function () {
        this.subscription.unsubscribe();
    };
    ScrollReached.prototype.scrollReached = function () {
        var _this = this;
        // current event
        var currEvent;
        return this.scrollEvent.pipe(tap(function (e) { return currEvent = e; }), 
        // Check if it scroll has reached
        map(function (e) { return _this.reached(_this.offset, e); }), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter(function (reached) { return reached; }), 
        // Return scroll event
        map(function () { return currEvent; }));
    };
    __decorate([
        Input('reachedOffset'),
        __metadata("design:type", Object)
    ], ScrollReached.prototype, "offset", void 0);
    return ScrollReached;
}());
var VerticalScrollReached = /** @class */ (function (_super) {
    __extends(VerticalScrollReached, _super);
    function VerticalScrollReached(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        return _this;
    }
    VerticalScrollReached.prototype.ngOnInit = function () {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    };
    VerticalScrollReached = __decorate([
        __param(0, Optional()),
        __metadata("design:paramtypes", [NgScrollbar, NgZone])
    ], VerticalScrollReached);
    return VerticalScrollReached;
}(ScrollReached));
var HorizontalScrollReached = /** @class */ (function (_super) {
    __extends(HorizontalScrollReached, _super);
    function HorizontalScrollReached(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        return _this;
    }
    HorizontalScrollReached.prototype.ngOnInit = function () {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    };
    HorizontalScrollReached = __decorate([
        __param(0, Optional()),
        __metadata("design:paramtypes", [NgScrollbar, NgZone])
    ], HorizontalScrollReached);
    return HorizontalScrollReached;
}(ScrollReached));
var NgScrollbarReachedTop = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedTop, _super);
    function NgScrollbarReachedTop(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        _this.reachedTop = _this.reachedEvent;
        return _this;
    }
    NgScrollbarReachedTop.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    NgScrollbarReachedTop.prototype.reached = function (offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    };
    NgScrollbarReachedTop.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", Observable)
    ], NgScrollbarReachedTop.prototype, "reachedTop", void 0);
    NgScrollbarReachedTop = __decorate([
        Directive({
            selector: '[reachedTop], [reached-top]',
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [NgScrollbar, NgZone])
    ], NgScrollbarReachedTop);
    return NgScrollbarReachedTop;
}(VerticalScrollReached));
export { NgScrollbarReachedTop };
var NgScrollbarReachedBottom = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedBottom, _super);
    function NgScrollbarReachedBottom(scrollbar, zone) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        _this.reachedBottom = _this.reachedEvent;
        return _this;
    }
    NgScrollbarReachedBottom.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    NgScrollbarReachedBottom.prototype.reached = function (offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    };
    NgScrollbarReachedBottom.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", Observable)
    ], NgScrollbarReachedBottom.prototype, "reachedBottom", void 0);
    NgScrollbarReachedBottom = __decorate([
        Directive({
            selector: '[reachedBottom], [reached-bottom]',
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [NgScrollbar, NgZone])
    ], NgScrollbarReachedBottom);
    return NgScrollbarReachedBottom;
}(VerticalScrollReached));
export { NgScrollbarReachedBottom };
var NgScrollbarReachedStart = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedStart, _super);
    function NgScrollbarReachedStart(scrollbar, zone, dir) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        _this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        _this.reachedStart = _this.reachedEvent;
        return _this;
    }
    NgScrollbarReachedStart.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    NgScrollbarReachedStart.prototype.reached = function (offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    };
    NgScrollbarReachedStart.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone },
        { type: Directionality }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", Observable)
    ], NgScrollbarReachedStart.prototype, "reachedStart", void 0);
    NgScrollbarReachedStart = __decorate([
        Directive({
            selector: '[reachedStart], [reached-start]',
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
    ], NgScrollbarReachedStart);
    return NgScrollbarReachedStart;
}(HorizontalScrollReached));
export { NgScrollbarReachedStart };
var NgScrollbarReachedEnd = /** @class */ (function (_super) {
    __extends(NgScrollbarReachedEnd, _super);
    function NgScrollbarReachedEnd(scrollbar, zone, dir) {
        var _this = _super.call(this, scrollbar, zone) || this;
        _this.scrollbar = scrollbar;
        _this.zone = zone;
        _this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        _this.reachedEnd = _this.reachedEvent;
        return _this;
    }
    NgScrollbarReachedEnd.prototype.ngOnInit = function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    NgScrollbarReachedEnd.prototype.reached = function (offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    };
    NgScrollbarReachedEnd.ctorParameters = function () { return [
        { type: NgScrollbar, decorators: [{ type: Optional }] },
        { type: NgZone },
        { type: Directionality }
    ]; };
    __decorate([
        Output(),
        __metadata("design:type", Observable)
    ], NgScrollbarReachedEnd.prototype, "reachedEnd", void 0);
    NgScrollbarReachedEnd = __decorate([
        Directive({
            selector: '[reachedEnd], [reached-end]',
        }),
        __param(0, Optional()),
        __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
    ], NgScrollbarReachedEnd);
    return NgScrollbarReachedEnd;
}(HorizontalScrollReached));
export { NgScrollbarReachedEnd };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctc2Nyb2xsYmFyLXJlYWNoZWQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtc2Nyb2xsYmFyL3JlYWNoZWQtZXZlbnQvIiwic291cmNlcyI6WyJuZy1zY3JvbGxiYXItcmVhY2hlZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFbkQsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDNUMsbURBQW1EO0FBQ25ELHNEQUFzRDtBQUV0RDtJQUFBO0lBc0NBLENBQUM7SUFyQ1EsMkJBQVUsR0FBakIsVUFBa0IsTUFBYyxFQUFFLENBQU07UUFDdEMsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVNLDhCQUFhLEdBQXBCLFVBQXFCLE1BQWMsRUFBRSxDQUFNO1FBQ3pDLE9BQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzdHLENBQUM7SUFFTSw2QkFBWSxHQUFuQixVQUFvQixNQUFjLEVBQUUsQ0FBTSxFQUFFLFNB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SUFBRCw4QkFBQztDQUFBLEFBckJELENBQTZDLHVCQUF1QixHQXFCbkU7U0FyQlksdUJBQXVCO0FBMEJwQztJQUEyQyx5Q0FBdUI7SUFLaEUsK0JBQWtDLFNBQXNCLEVBQVksSUFBWSxFQUFVLEdBQW1CO1FBQTdHLFlBQ0Usa0JBQU0sU0FBUyxFQUFFLElBQUksQ0FBQyxTQUN2QjtRQUZpQyxlQUFTLEdBQVQsU0FBUyxDQUFhO1FBQVksVUFBSSxHQUFKLElBQUksQ0FBUTtRQUFVLFNBQUcsR0FBSCxHQUFHLENBQWdCO1FBSDdHLHdEQUF3RDtRQUM5QyxnQkFBVSxHQUFvQixLQUFJLENBQUMsWUFBWSxDQUFDOztJQUkxRCxDQUFDO0lBRUQsd0NBQVEsR0FBUjtRQUNFLGlCQUFNLFFBQVEsV0FBRSxDQUFDO0lBQ25CLENBQUM7SUFFRDs7OztPQUlHO0lBQ08sdUNBQU8sR0FBakIsVUFBa0IsTUFBYyxFQUFFLENBQU07UUFDdEMsT0FBTyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQzFHLENBQUM7O2dCQWY0QyxXQUFXLHVCQUEzQyxRQUFRO2dCQUFxRCxNQUFNO2dCQUFlLGNBQWM7O0lBRm5HO1FBQVQsTUFBTSxFQUFFO2tDQUFhLFVBQVU7NkRBQTBCO0lBSC9DLHFCQUFxQjtRQUhqQyxTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsNkJBQTZCO1NBQ3hDLENBQUM7UUFNYSxXQUFBLFFBQVEsRUFBRSxDQUFBO3lDQUFzQixXQUFXLEVBQWtCLE1BQU0sRUFBZSxjQUFjO09BTGxHLHFCQUFxQixDQXFCakM7SUFBRCw0QkFBQztDQUFBLEFBckJELENBQTJDLHVCQUF1QixHQXFCakU7U0FyQlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBPcHRpb25hbCwgSW5wdXQsIE91dHB1dCwgT25Jbml0LCBPbkRlc3Ryb3ksIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBSdGxTY3JvbGxBeGlzVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24sIFN1YnNjcmliZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbHRlciwgbWFwLCB0YXAsIGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgTmdTY3JvbGxiYXIgfSBmcm9tICduZ3gtc2Nyb2xsYmFyJztcbi8vIFVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmUgaW4gZGV2ZWxvcG1lbnQgbW9kZVxuLy8gaW1wb3J0IHsgTmdTY3JvbGxiYXIgfSBmcm9tICcuLi8uLi9zcmMvcHVibGljLWFwaSc7XG5cbmNsYXNzIFJlYWNoZWRGdW5jdGlvbnMge1xuICBzdGF0aWMgcmVhY2hlZFRvcChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtZS50YXJnZXQuc2Nyb2xsVG9wLCAwLCBvZmZzZXQpO1xuICB9XG5cbiAgc3RhdGljIHJlYWNoZWRCb3R0b20ob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoZS50YXJnZXQuc2Nyb2xsVG9wICsgZS50YXJnZXQuY2xpZW50SGVpZ2h0LCBlLnRhcmdldC5zY3JvbGxIZWlnaHQsIG9mZnNldCk7XG4gIH1cblxuICBzdGF0aWMgcmVhY2hlZFN0YXJ0KG9mZnNldDogbnVtYmVyLCBlOiBhbnksIGRpcmVjdGlvbjogJ2x0cicgfCAncnRsJywgcnRsU2Nyb2xsQXhpc1R5cGU6IFJ0bFNjcm9sbEF4aXNUeXBlKTogYm9vbGVhbiB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuTkVHQVRFRCkge1xuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLklOVkVSVEVEKSB7XG4gICAgICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbExlZnQgKyBlLnRhcmdldC5jbGllbnRXaWR0aCwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWQoLWUudGFyZ2V0LnNjcm9sbExlZnQsIDAsIG9mZnNldCk7XG4gIH1cblxuICBzdGF0aWMgcmVhY2hlZEVuZChvZmZzZXQ6IG51bWJlciwgZTogYW55LCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcsIHJ0bFNjcm9sbEF4aXNUeXBlOiBSdGxTY3JvbGxBeGlzVHlwZSk6IGJvb2xlYW4ge1xuICAgIGlmIChkaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICBpZiAocnRsU2Nyb2xsQXhpc1R5cGUgPT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5FR0FURUQpIHtcbiAgICAgICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZCgtKGUudGFyZ2V0LnNjcm9sbExlZnQgLSBlLnRhcmdldC5jbGllbnRXaWR0aCksIGUudGFyZ2V0LnNjcm9sbFdpZHRoLCBvZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5JTlZFUlRFRCkge1xuICAgICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC0oZS50YXJnZXQuc2Nyb2xsTGVmdCArIGUudGFyZ2V0LmNsaWVudFdpZHRoKSwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKC1lLnRhcmdldC5zY3JvbGxMZWZ0LCAwLCBvZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkKGUudGFyZ2V0LnNjcm9sbExlZnQgKyBlLnRhcmdldC5jbGllbnRXaWR0aCwgZS50YXJnZXQuc2Nyb2xsV2lkdGgsIG9mZnNldCk7XG4gIH1cblxuICBzdGF0aWMgcmVhY2hlZChjdXJyUG9zaXRpb246IG51bWJlciwgdGFyZ2V0UG9zaXRpb246IG51bWJlciwgb2Zmc2V0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gY3VyclBvc2l0aW9uID49IHRhcmdldFBvc2l0aW9uIC0gb2Zmc2V0O1xuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIC8qKiBvZmZzZXQ6IFJlYWNoZWQgb2Zmc2V0IHZhbHVlIGluIHB4ICovXG4gIEBJbnB1dCgncmVhY2hlZE9mZnNldCcpIG9mZnNldCA9IDA7XG5cbiAgLyoqXG4gICAqIFN0cmVhbSB0aGF0IGVtaXRzIHNjcm9sbCBldmVudCB3aGVuIGBOZ1Njcm9sbGJhci5zY3JvbGxlZGAgaXMgaW5pdGlhbGl6ZWQuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIHN1YmplY3QgaXMgdXNlZCB0byBob2xkIHRoZSBwbGFjZSBvZiBgTmdTY3JvbGxiYXIuc2Nyb2xsZWRgIHdoZW4gaXQncyBub3QgaW5pdGlhbGl6ZWQgeWV0XG4gICAqL1xuICBwcm90ZWN0ZWQgc2Nyb2xsRXZlbnQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgLyoqIHN1YnNjcmlwdGlvbjogU2Nyb2xsZWQgZXZlbnQgc3Vic2NyaXB0aW9uLCB1c2VkIHRvIHVuc3Vic2NyaWJlIGZyb20gdGhlIGV2ZW50IG9uIGRlc3Ryb3kgKi9cbiAgcHJvdGVjdGVkIHN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcblxuICAvKiogQSBzdHJlYW0gdXNlZCB0byBhc3NpZ24gdGhlIHJlYWNoZWQgb3V0cHV0ICovXG4gIHByb3RlY3RlZCByZWFjaGVkRXZlbnQgPSBuZXcgT2JzZXJ2YWJsZSgoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxhbnk+KSA9PlxuICAgIHRoaXMuc2Nyb2xsUmVhY2hlZCgpLnN1YnNjcmliZShfID0+XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMuem9uZS5ydW4oKCkgPT4gc3Vic2NyaWJlci5uZXh0KF8pKSkpKTtcblxuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IocHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBpZiAoIXNjcm9sbGJhcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdbTmdTY3JvbGxiYXJSZWFjaGVkIERpcmVjdGl2ZV06IEhvc3QgZWxlbWVudCBtdXN0IGJlIGFuIE5nU2Nyb2xsYmFyIGNvbXBvbmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHNjcm9sbFJlYWNoZWQoKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAvLyBjdXJyZW50IGV2ZW50XG4gICAgbGV0IGN1cnJFdmVudDogYW55O1xuXG4gICAgcmV0dXJuIHRoaXMuc2Nyb2xsRXZlbnQucGlwZShcbiAgICAgIHRhcCgoZSkgPT4gY3VyckV2ZW50ID0gZSksXG4gICAgICAvLyBDaGVjayBpZiBpdCBzY3JvbGwgaGFzIHJlYWNoZWRcbiAgICAgIG1hcCgoZSkgPT4gdGhpcy5yZWFjaGVkKHRoaXMub2Zmc2V0LCBlKSksXG4gICAgICAvLyBEaXN0aW5jdCB1bnRpbCByZWFjaGVkIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgLy8gRW1pdCBvbmx5IGlmIHJlYWNoZWQgaXMgdHJ1ZVxuICAgICAgZmlsdGVyKChyZWFjaGVkOiBib29sZWFuKSA9PiByZWFjaGVkKSxcbiAgICAgIC8vIFJldHVybiBzY3JvbGwgZXZlbnRcbiAgICAgIG1hcCgoKSA9PiBjdXJyRXZlbnQpXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlPzogYW55KTogYm9vbGVhbjtcbn1cblxuYWJzdHJhY3QgY2xhc3MgVmVydGljYWxTY3JvbGxSZWFjaGVkIGV4dGVuZHMgU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsYmFyLnZlcnRpY2FsU2Nyb2xsZWQuc3Vic2NyaWJlKHRoaXMuc2Nyb2xsRXZlbnQpO1xuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEhvcml6b250YWxTY3JvbGxSZWFjaGVkIGV4dGVuZHMgU2Nyb2xsUmVhY2hlZCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuc2Nyb2xsYmFyLmhvcml6b250YWxTY3JvbGxlZC5zdWJzY3JpYmUodGhpcy5zY3JvbGxFdmVudCk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3JlYWNoZWRUb3BdLCBbcmVhY2hlZC10b3BdJyxcbn0pXG5leHBvcnQgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkVG9wIGV4dGVuZHMgVmVydGljYWxTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAqL1xuICBAT3V0cHV0KCkgcmVhY2hlZFRvcDogT2JzZXJ2YWJsZTxhbnk+ID0gdGhpcy5yZWFjaGVkRXZlbnQ7XG5cbiAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIHNjcm9sbGJhcjogTmdTY3JvbGxiYXIsIHByb3RlY3RlZCB6b25lOiBOZ1pvbmUpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHRvcCAodmVydGljYWxseSlcbiAgICogQHBhcmFtIG9mZnNldCBTY3JvbGwgb2Zmc2V0XG4gICAqIEBwYXJhbSBlIFNjcm9sbCBldmVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWNoZWQob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWRUb3Aob2Zmc2V0LCBlKTtcbiAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbcmVhY2hlZEJvdHRvbV0sIFtyZWFjaGVkLWJvdHRvbV0nLFxufSlcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRCb3R0b20gZXh0ZW5kcyBWZXJ0aWNhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgYm90dG9tICovXG4gIEBPdXRwdXQoKSByZWFjaGVkQm90dG9tOiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSkge1xuICAgIHN1cGVyKHNjcm9sbGJhciwgem9uZSk7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgYm90dG9tICh2ZXJ0aWNhbGx5KVxuICAgKiBAcGFyYW0gb2Zmc2V0IFNjcm9sbCBvZmZzZXRcbiAgICogQHBhcmFtIGUgU2Nyb2xsIGV2ZW50XG4gICAqL1xuICBwcm90ZWN0ZWQgcmVhY2hlZChvZmZzZXQ6IG51bWJlciwgZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFJlYWNoZWRGdW5jdGlvbnMucmVhY2hlZEJvdHRvbShvZmZzZXQsIGUpO1xuICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tyZWFjaGVkU3RhcnRdLCBbcmVhY2hlZC1zdGFydF0nLFxufSlcbmV4cG9ydCBjbGFzcyBOZ1Njcm9sbGJhclJlYWNoZWRTdGFydCBleHRlbmRzIEhvcml6b250YWxTY3JvbGxSZWFjaGVkIGltcGxlbWVudHMgT25Jbml0IHtcblxuICAvKiogU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHN0YXJ0ICovXG4gIEBPdXRwdXQoKSByZWFjaGVkU3RhcnQ6IE9ic2VydmFibGU8YW55PiA9IHRoaXMucmVhY2hlZEV2ZW50O1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIHByb3RlY3RlZCBzY3JvbGxiYXI6IE5nU2Nyb2xsYmFyLCBwcm90ZWN0ZWQgem9uZTogTmdab25lLCBwcml2YXRlIGRpcjogRGlyZWN0aW9uYWxpdHkpIHtcbiAgICBzdXBlcihzY3JvbGxiYXIsIHpvbmUpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgc3VwZXIubmdPbkluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBzY3JvbGwgaGFzIHJlYWNoZWQgdGhlIHN0YXJ0IChob3Jpem9udGFsbHkpXG4gICAqIEBwYXJhbSBvZmZzZXQgU2Nyb2xsIG9mZnNldFxuICAgKiBAcGFyYW0gZSBTY3JvbGwgZXZlbnRcbiAgICovXG4gIHByb3RlY3RlZCByZWFjaGVkKG9mZnNldDogbnVtYmVyLCBlOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gUmVhY2hlZEZ1bmN0aW9ucy5yZWFjaGVkU3RhcnQob2Zmc2V0LCBlLCB0aGlzLmRpci52YWx1ZSwgdGhpcy5zY3JvbGxiYXIubWFuYWdlci5ydGxTY3JvbGxBeGlzVHlwZSk7XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3JlYWNoZWRFbmRdLCBbcmVhY2hlZC1lbmRdJyxcbn0pXG5leHBvcnQgY2xhc3MgTmdTY3JvbGxiYXJSZWFjaGVkRW5kIGV4dGVuZHMgSG9yaXpvbnRhbFNjcm9sbFJlYWNoZWQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIC8qKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIHNjcm9sbCBoYXMgcmVhY2hlZCB0aGUgZW5kICovXG4gIEBPdXRwdXQoKSByZWFjaGVkRW5kOiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlYWNoZWRFdmVudDtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgc2Nyb2xsYmFyOiBOZ1Njcm9sbGJhciwgcHJvdGVjdGVkIHpvbmU6IE5nWm9uZSwgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5KSB7XG4gICAgc3VwZXIoc2Nyb2xsYmFyLCB6b25lKTtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgc2Nyb2xsIGhhcyByZWFjaGVkIHRoZSBlbmQgKGhvcml6b250YWxseSlcbiAgICogQHBhcmFtIG9mZnNldCBTY3JvbGwgb2Zmc2V0XG4gICAqIEBwYXJhbSBlIFNjcm9sbCBldmVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHJlYWNoZWQob2Zmc2V0OiBudW1iZXIsIGU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBSZWFjaGVkRnVuY3Rpb25zLnJlYWNoZWRFbmQob2Zmc2V0LCBlLCB0aGlzLmRpci52YWx1ZSwgdGhpcy5zY3JvbGxiYXIubWFuYWdlci5ydGxTY3JvbGxBeGlzVHlwZSk7XG4gIH1cbn1cbiJdfQ==