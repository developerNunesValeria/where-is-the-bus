import { __assign, __decorate, __metadata, __param } from "tslib";
import { Inject, Injectable, PLATFORM_ID, Optional } from '@angular/core';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';
import { coerceElement } from '@angular/cdk/coercion';
import { getRtlScrollAxisType } from '@angular/cdk/platform';
import { fromEvent, merge, of, Observable, Subject, animationFrameScheduler } from 'rxjs';
import { expand, finalize, take, takeUntil, takeWhile } from 'rxjs/operators';
import BezierEasing from 'bezier-easing';
import { SMOOTH_SCROLL_OPTIONS } from './smooth-scroll.model';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./smooth-scroll.model";
// @dynamic
var SmoothScrollManager = /** @class */ (function () {
    function SmoothScrollManager(_document, _platform, customDefaultOptions) {
        this._document = _document;
        this._platform = _platform;
        // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.
        // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.
        // Purpose: If user called a scroll function again on the same element before the scrolls completes,
        // it cancels the ongoing scroll and starts a new one
        this._onGoingScrolls = new Map();
        this._defaultOptions = __assign({ duration: 468, easing: {
                x1: 0.42,
                y1: 0,
                x2: 0.58,
                y2: 1
            } }, customDefaultOptions);
    }
    Object.defineProperty(SmoothScrollManager.prototype, "_w", {
        get: function () {
            return this._document.defaultView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SmoothScrollManager.prototype, "_now", {
        /**
         * Timing method
         */
        get: function () {
            return this._w.performance && this._w.performance.now
                ? this._w.performance.now.bind(this._w.performance)
                : Date.now;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * changes scroll position inside an element
     */
    SmoothScrollManager.prototype._scrollElement = function (el, x, y) {
        el.scrollLeft = x;
        el.scrollTop = y;
    };
    /**
     * Handles a given parameter of type HTMLElement, ElementRef or selector
     */
    SmoothScrollManager.prototype._getElement = function (el, parent) {
        if (typeof el === 'string') {
            return (parent || this._document).querySelector(el);
        }
        return coerceElement(el);
    };
    /**
     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled
     */
    SmoothScrollManager.prototype._initSmoothScroll = function (el) {
        if (this._onGoingScrolls.has(el)) {
            this._onGoingScrolls.get(el).next();
        }
        return this._onGoingScrolls.set(el, new Subject()).get(el);
    };
    /**
     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise
     */
    SmoothScrollManager.prototype._isFinished = function (context, destroyed, resolve) {
        if (context.currentX !== context.x || context.currentY !== context.y) {
            return true;
        }
        destroyed.next();
        resolve();
        return false;
    };
    /**
     * Terminates an ongoing smooth scroll
     */
    SmoothScrollManager.prototype._interrupted = function (el, destroyed) {
        return merge(fromEvent(el, 'wheel', { passive: true, capture: true }), fromEvent(el, 'touchmove', { passive: true, capture: true }), destroyed).pipe(take(1));
    };
    /**
     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted
     */
    SmoothScrollManager.prototype._destroy = function (el, destroyed) {
        destroyed.complete();
        this._onGoingScrolls.delete(el);
    };
    /**
     * A function called recursively that, given a context, steps through scrolling
     */
    SmoothScrollManager.prototype._step = function (context) {
        var _this = this;
        return new Observable(function (subscriber) {
            var elapsed = (_this._now() - context.startTime) / context.duration;
            // avoid elapsed times higher than one
            elapsed = elapsed > 1 ? 1 : elapsed;
            // apply easing to elapsed time
            var value = context.easing(elapsed);
            context.currentX = context.startX + (context.x - context.startX) * value;
            context.currentY = context.startY + (context.y - context.startY) * value;
            _this._scrollElement(context.scrollable, context.currentX, context.currentY);
            // Proceed to the step
            animationFrameScheduler.schedule(function () { return subscriber.next(context); });
        });
    };
    SmoothScrollManager.prototype._applyScrollToOptions = function (el, options) {
        var _this = this;
        if (!options.duration) {
            this._scrollElement(el, options.left, options.top);
            return Promise.resolve();
        }
        // Initialize a destroyer stream, reinitialize it if the element is already being scrolled
        var destroyed = this._initSmoothScroll(el);
        var context = {
            scrollable: el,
            startTime: this._now(),
            startX: el.scrollLeft,
            startY: el.scrollTop,
            x: options.left == null ? el.scrollLeft : ~~options.left,
            y: options.top == null ? el.scrollTop : ~~options.top,
            duration: options.duration,
            easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)
        };
        return new Promise(function (resolve) {
            // Scroll each step recursively
            of(null).pipe(expand(function () { return _this._step(context).pipe(takeWhile(function (currContext) { return _this._isFinished(currContext, destroyed, resolve); })); }), takeUntil(_this._interrupted(el, destroyed)), finalize(function () { return _this._destroy(el, destroyed); })).subscribe();
        });
    };
    /**
     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
     * left and right always refer to the left and right side of the scrolling container irrespective
     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
     * in an RTL context.
     * @param scrollable element
     * @param customOptions specified the offsets to scroll to.
     */
    SmoothScrollManager.prototype.scrollTo = function (scrollable, customOptions) {
        if (isPlatformBrowser(this._platform)) {
            var el = this._getElement(scrollable);
            var isRtl = getComputedStyle(el).direction === 'rtl';
            var rtlScrollAxisType = getRtlScrollAxisType();
            var options = __assign(__assign(__assign({}, this._defaultOptions), customOptions), {
                // Rewrite start & end offsets as right or left offsets.
                left: customOptions.left == null ? (isRtl ? customOptions.end : customOptions.start) : customOptions.left,
                right: customOptions.right == null ? (isRtl ? customOptions.start : customOptions.end) : customOptions.right
            });
            // Rewrite the bottom offset as a top offset.
            if (options.bottom != null) {
                options.top = el.scrollHeight - el.clientHeight - options.bottom;
            }
            // Rewrite the right offset as a left offset.
            if (isRtl && rtlScrollAxisType !== 0 /* NORMAL */) {
                if (options.left != null) {
                    options.right = el.scrollWidth - el.clientWidth - options.left;
                }
                if (rtlScrollAxisType === 2 /* INVERTED */) {
                    options.left = options.right;
                }
                else if (rtlScrollAxisType === 1 /* NEGATED */) {
                    options.left = options.right ? -options.right : options.right;
                }
            }
            else {
                if (options.right != null) {
                    options.left = el.scrollWidth - el.clientWidth - options.right;
                }
            }
            return this._applyScrollToOptions(el, options);
        }
        return Promise.resolve();
    };
    /**
     * Scroll to element by reference or selector
     */
    SmoothScrollManager.prototype.scrollToElement = function (scrollable, target, customOptions) {
        var scrollableEl = this._getElement(scrollable);
        var targetEl = this._getElement(target, scrollableEl);
        var options = __assign(__assign({}, customOptions), {
            left: targetEl.offsetLeft + (customOptions.left || 0),
            top: targetEl.offsetTop + (customOptions.top || 0)
        });
        return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();
    };
    SmoothScrollManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SMOOTH_SCROLL_OPTIONS,] }] }
    ]; };
    SmoothScrollManager.ɵprov = i0.ɵɵdefineInjectable({ factory: function SmoothScrollManager_Factory() { return new SmoothScrollManager(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i2.SMOOTH_SCROLL_OPTIONS, 8)); }, token: SmoothScrollManager, providedIn: "root" });
    SmoothScrollManager = __decorate([
        Injectable({
            providedIn: 'root'
        }),
        __param(0, Inject(DOCUMENT)),
        __param(1, Inject(PLATFORM_ID)),
        __param(2, Optional()), __param(2, Inject(SMOOTH_SCROLL_OPTIONS)),
        __metadata("design:paramtypes", [Object, Object, Object])
    ], SmoothScrollManager);
    return SmoothScrollManager;
}());
export { SmoothScrollManager };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21vb3RoLXNjcm9sbC1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXNjcm9sbGJhci9zbW9vdGgtc2Nyb2xsLyIsInNvdXJjZXMiOlsic21vb3RoLXNjcm9sbC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQWMsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RGLE9BQU8sRUFBRSxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdEQsT0FBTyxFQUFFLG9CQUFvQixFQUFxQixNQUFNLHVCQUF1QixDQUFDO0FBRWhGLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFjLHVCQUF1QixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RHLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUUsT0FBTyxZQUFZLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFDTCxxQkFBcUIsRUFLdEIsTUFBTSx1QkFBdUIsQ0FBQzs7OztBQUUvQixXQUFXO0FBSVg7SUF3QkUsNkJBQXNDLFNBQWMsRUFDWCxTQUFpQixFQUNILG9CQUEyQztRQUY1RCxjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQ1gsY0FBUyxHQUFULFNBQVMsQ0FBUTtRQXBCMUQsbUdBQW1HO1FBQ25HLG1HQUFtRztRQUNuRyxvR0FBb0c7UUFDcEcscURBQXFEO1FBQzdDLG9CQUFlLEdBQUcsSUFBSSxHQUFHLEVBQThCLENBQUM7UUFrQjlELElBQUksQ0FBQyxlQUFlLGNBQ2xCLFFBQVEsRUFBRSxHQUFHLEVBQ2IsTUFBTSxFQUFFO2dCQUNOLEVBQUUsRUFB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SUFDSCw2Q0FBZSxHQUFmLFVBQWdCLFVBQStCLEVBQUUsTUFBMkIsRUFBRSxhQUFpRDtRQUM3SCxJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2xELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3hELElBQU0sT0FBTyx5QkFDUixhQUFhLEdBQ2I7WUFDRCxJQUFJLEVBQUUsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDO1lBQ3JELEdBQUcsRUFBRSxRQUFRLENBQUMsU0FBUyxHQUFHLENBQUMsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7U0FDbkQsQ0FDRixDQUFDO1FBQ0YsT0FBTyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDN0UsQ0FBQzs7Z0RBbE1ZLE1BQU0sU0FBQyxRQUFROzZDQUNmLE1BQU0sU0FBQyxXQUFXO2dEQUNsQixRQUFRLFlBQUksTUFBTSxTQUFDLHFCQUFxQjs7O0lBMUIxQyxtQkFBbUI7UUFIL0IsVUFBVSxDQUFDO1lBQ1YsVUFBVSxFQUFFLE1BQU07U0FDbkIsQ0FBQztRQXlCYSxXQUFBLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUNoQixXQUFBLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQTtRQUNuQixXQUFBLFFBQVEsRUFBRSxDQUFBLEVBQUUsV0FBQSxNQUFNLENBQUMscUJBQXFCLENBQUMsQ0FBQTs7T0ExQjNDLG1CQUFtQixDQTJOL0I7OEJBL09EO0NBK09DLEFBM05ELElBMk5DO1NBM05ZLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdCwgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBET0NVTUVOVCwgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgY29lcmNlRWxlbWVudCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBnZXRSdGxTY3JvbGxBeGlzVHlwZSwgUnRsU2Nyb2xsQXhpc1R5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcGxhdGZvcm0nO1xuaW1wb3J0IHsgX0JvdHRvbSwgX0xlZnQsIF9SaWdodCwgX1RvcCwgX1dpdGhvdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIG9mLCBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpYmVyLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZXhwYW5kLCBmaW5hbGl6ZSwgdGFrZSwgdGFrZVVudGlsLCB0YWtlV2hpbGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgQmV6aWVyRWFzaW5nIGZyb20gJ2Jlemllci1lYXNpbmcnO1xuaW1wb3J0IHtcbiAgU01PT1RIX1NDUk9MTF9PUFRJT05TLFxuICBTbW9vdGhTY3JvbGxFbGVtZW50LFxuICBTbW9vdGhTY3JvbGxPcHRpb25zLFxuICBTbW9vdGhTY3JvbGxTdGVwLFxuICBTbW9vdGhTY3JvbGxUb09wdGlvbnNcbn0gZnJvbSAnLi9zbW9vdGgtc2Nyb2xsLm1vZGVsJztcblxuLy8gQGR5bmFtaWNcbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFNtb290aFNjcm9sbE1hbmFnZXIge1xuXG4gIC8vIERlZmF1bHQgb3B0aW9uc1xuICBwcml2YXRlIHJlYWRvbmx5IF9kZWZhdWx0T3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zO1xuXG4gIC8vIEtlZXBzIHRyYWNrIG9mIHRoZSBvbmdvaW5nIFNtb290aFNjcm9sbCBmdW5jdGlvbnMgc28gdGhleSBjYW4gYmUgaGFuZGxlZCBpbiBjYXNlIG9mIGR1cGxpY2F0aW9uLlxuICAvLyBFYWNoIHNjcm9sbGVkIGVsZW1lbnQgZ2V0cyBhIGRlc3Ryb3llciBzdHJlYW0gd2hpY2ggZ2V0cyBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGNvbXBsZXRlcy5cbiAgLy8gUHVycG9zZTogSWYgdXNlciBjYWxsZWQgYSBzY3JvbGwgZnVuY3Rpb24gYWdhaW4gb24gdGhlIHNhbWUgZWxlbWVudCBiZWZvcmUgdGhlIHNjcm9sbHMgY29tcGxldGVzLFxuICAvLyBpdCBjYW5jZWxzIHRoZSBvbmdvaW5nIHNjcm9sbCBhbmQgc3RhcnRzIGEgbmV3IG9uZVxuICBwcml2YXRlIF9vbkdvaW5nU2Nyb2xscyA9IG5ldyBNYXA8SFRNTEVsZW1lbnQsIFN1YmplY3Q8dm9pZD4+KCk7XG5cbiAgcHJpdmF0ZSBnZXQgX3coKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIH1cblxuICAvKipcbiAgICogVGltaW5nIG1ldGhvZFxuICAgKi9cbiAgcHJpdmF0ZSBnZXQgX25vdygpIHtcbiAgICByZXR1cm4gdGhpcy5fdy5wZXJmb3JtYW5jZSAmJiB0aGlzLl93LnBlcmZvcm1hbmNlLm5vd1xuICAgICAgPyB0aGlzLl93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHRoaXMuX3cucGVyZm9ybWFuY2UpXG4gICAgICA6IERhdGUubm93O1xuICB9XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcbiAgICAgICAgICAgICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBfcGxhdGZvcm06IG9iamVjdCxcbiAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChTTU9PVEhfU0NST0xMX09QVElPTlMpIGN1c3RvbURlZmF1bHRPcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpIHtcbiAgICB0aGlzLl9kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGR1cmF0aW9uOiA0NjgsXG4gICAgICBlYXNpbmc6IHtcbiAgICAgICAgeDE6IDAuNDIsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4MjogMC41OCxcbiAgICAgICAgeTI6IDFcbiAgICAgIH0sXG4gICAgICAuLi5jdXN0b21EZWZhdWx0T3B0aW9ucyxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIF9zY3JvbGxFbGVtZW50KGVsOiBIVE1MRWxlbWVudCwgeDogbnVtYmVyLCB5OiBudW1iZXIpOiB2b2lkIHtcbiAgICBlbC5zY3JvbGxMZWZ0ID0geDtcbiAgICBlbC5zY3JvbGxUb3AgPSB5O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBnaXZlbiBwYXJhbWV0ZXIgb2YgdHlwZSBIVE1MRWxlbWVudCwgRWxlbWVudFJlZiBvciBzZWxlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0RWxlbWVudChlbDogSFRNTEVsZW1lbnQgfCBFbGVtZW50UmVmIHwgc3RyaW5nLCBwYXJlbnQ/OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIChwYXJlbnQgfHwgdGhpcy5fZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIH1cbiAgICByZXR1cm4gY29lcmNlRWxlbWVudDxIVE1MRWxlbWVudD4oZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgZGVzdHJveWVyIHN0cmVhbSwgcmUtaW5pdGlhbGl6ZXMgaXQgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBzY3JvbGxlZFxuICAgKi9cbiAgcHJpdmF0ZSBfaW5pdFNtb290aFNjcm9sbChlbDogSFRNTEVsZW1lbnQpOiBTdWJqZWN0PHZvaWQ+IHtcbiAgICBpZiAodGhpcy5fb25Hb2luZ1Njcm9sbHMuaGFzKGVsKSkge1xuICAgICAgdGhpcy5fb25Hb2luZ1Njcm9sbHMuZ2V0KGVsKSEubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb25Hb2luZ1Njcm9sbHMuc2V0KGVsLCBuZXcgU3ViamVjdDx2b2lkPigpKSEuZ2V0KGVsKSE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNtb290aCBzY3JvbGwgaGFzIHJlYWNoZWQsIGNsZWFucyB1cCB0aGUgc21vb3RoIHNjcm9sbCBzdHJlYW0gYW5kIHJlc29sdmVzIGl0cyBwcm9taXNlXG4gICAqL1xuICBwcml2YXRlIF9pc0ZpbmlzaGVkKGNvbnRleHQ6IFNtb290aFNjcm9sbFN0ZXAsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPiwgcmVzb2x2ZTogKCkgPT4gdm9pZCk6IGJvb2xlYW4ge1xuICAgIGlmIChjb250ZXh0LmN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY29udGV4dC5jdXJyZW50WSAhPT0gY29udGV4dC55KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVzdHJveWVkLm5leHQoKTtcbiAgICByZXNvbHZlKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlcm1pbmF0ZXMgYW4gb25nb2luZyBzbW9vdGggc2Nyb2xsXG4gICAqL1xuICBwcml2YXRlIF9pbnRlcnJ1cHRlZChlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIG1lcmdlKFxuICAgICAgZnJvbUV2ZW50KGVsLCAnd2hlZWwnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXG4gICAgICBmcm9tRXZlbnQoZWwsICd0b3VjaG1vdmUnLCB7IHBhc3NpdmU6IHRydWUsIGNhcHR1cmU6IHRydWUgfSksXG4gICAgICBkZXN0cm95ZWRcbiAgICApLnBpcGUodGFrZSgxKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0aGUgZGVzdHJveWVyIGZ1bmN0aW9uLCBydW5zIGlmIHRoZSBzbW9vdGggc2Nyb2xsIGhhcyBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZFxuICAgKi9cbiAgcHJpdmF0ZSBfZGVzdHJveShlbDogSFRNTEVsZW1lbnQsIGRlc3Ryb3llZDogU3ViamVjdDx2b2lkPik6IHZvaWQge1xuICAgIGRlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuX29uR29pbmdTY3JvbGxzLmRlbGV0ZShlbCk7XG4gIH1cblxuICAvKipcbiAgICogQSBmdW5jdGlvbiBjYWxsZWQgcmVjdXJzaXZlbHkgdGhhdCwgZ2l2ZW4gYSBjb250ZXh0LCBzdGVwcyB0aHJvdWdoIHNjcm9sbGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBfc3RlcChjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKTogT2JzZXJ2YWJsZTxTbW9vdGhTY3JvbGxTdGVwPiB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFNtb290aFNjcm9sbFN0ZXA+KSA9PiB7XG4gICAgICBsZXQgZWxhcHNlZCA9ICh0aGlzLl9ub3coKSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIGNvbnRleHQuZHVyYXRpb247XG5cbiAgICAgIC8vIGF2b2lkIGVsYXBzZWQgdGltZXMgaGlnaGVyIHRoYW4gb25lXG4gICAgICBlbGFwc2VkID0gZWxhcHNlZCA+IDEgPyAxIDogZWxhcHNlZDtcblxuICAgICAgLy8gYXBwbHkgZWFzaW5nIHRvIGVsYXBzZWQgdGltZVxuICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0LmVhc2luZyhlbGFwc2VkKTtcblxuICAgICAgY29udGV4dC5jdXJyZW50WCA9IGNvbnRleHQuc3RhcnRYICsgKGNvbnRleHQueCAtIGNvbnRleHQuc3RhcnRYKSAqIHZhbHVlO1xuICAgICAgY29udGV4dC5jdXJyZW50WSA9IGNvbnRleHQuc3RhcnRZICsgKGNvbnRleHQueSAtIGNvbnRleHQuc3RhcnRZKSAqIHZhbHVlO1xuXG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGNvbnRleHQuc2Nyb2xsYWJsZSwgY29udGV4dC5jdXJyZW50WCwgY29udGV4dC5jdXJyZW50WSk7XG4gICAgICAvLyBQcm9jZWVkIHRvIHRoZSBzdGVwXG4gICAgICBhbmltYXRpb25GcmFtZVNjaGVkdWxlci5zY2hlZHVsZSgoKSA9PiBzdWJzY3JpYmVyLm5leHQoY29udGV4dCkpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfYXBwbHlTY3JvbGxUb09wdGlvbnMoZWw6IEhUTUxFbGVtZW50LCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIW9wdGlvbnMuZHVyYXRpb24hKSB7XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50KGVsLCBvcHRpb25zIS5sZWZ0ISwgb3B0aW9ucyEudG9wISk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBhIGRlc3Ryb3llciBzdHJlYW0sIHJlaW5pdGlhbGl6ZSBpdCBpZiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIHNjcm9sbGVkXG4gICAgY29uc3QgZGVzdHJveWVkOiBTdWJqZWN0PHZvaWQ+ID0gdGhpcy5faW5pdFNtb290aFNjcm9sbChlbCk7XG5cbiAgICBjb25zdCBjb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwID0ge1xuICAgICAgc2Nyb2xsYWJsZTogZWwsXG4gICAgICBzdGFydFRpbWU6IHRoaXMuX25vdygpLFxuICAgICAgc3RhcnRYOiBlbC5zY3JvbGxMZWZ0LFxuICAgICAgc3RhcnRZOiBlbC5zY3JvbGxUb3AsXG4gICAgICB4OiBvcHRpb25zLmxlZnQgPT0gbnVsbCA/IGVsLnNjcm9sbExlZnQgOiB+fm9wdGlvbnMubGVmdCxcbiAgICAgIHk6IG9wdGlvbnMudG9wID09IG51bGwgPyBlbC5zY3JvbGxUb3AgOiB+fm9wdGlvbnMudG9wLFxuICAgICAgZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24hLFxuICAgICAgZWFzaW5nOiBCZXppZXJFYXNpbmcob3B0aW9ucy5lYXNpbmchLngxISwgb3B0aW9ucy5lYXNpbmchLnkxISwgb3B0aW9ucy5lYXNpbmchLngyISwgb3B0aW9ucy5lYXNpbmchLnkyISlcbiAgICB9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgLy8gU2Nyb2xsIGVhY2ggc3RlcCByZWN1cnNpdmVseVxuICAgICAgb2YobnVsbCkucGlwZShcbiAgICAgICAgZXhwYW5kKCgpID0+IHRoaXMuX3N0ZXAoY29udGV4dCkucGlwZShcbiAgICAgICAgICB0YWtlV2hpbGUoKGN1cnJDb250ZXh0OiBTbW9vdGhTY3JvbGxTdGVwKSA9PiB0aGlzLl9pc0ZpbmlzaGVkKGN1cnJDb250ZXh0LCBkZXN0cm95ZWQsIHJlc29sdmUpKVxuICAgICAgICApKSxcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX2ludGVycnVwdGVkKGVsLCBkZXN0cm95ZWQpKSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5fZGVzdHJveShlbCwgZGVzdHJveWVkKSlcbiAgICAgICkuc3Vic2NyaWJlKCk7XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0cy4gVGhpcyBpcyBhIG5vcm1hbGl6ZWQgdmVyc2lvbiBvZiB0aGUgYnJvd3NlcidzIG5hdGl2ZSBzY3JvbGxUb1xuICAgKiBtZXRob2QsIHNpbmNlIGJyb3dzZXJzIGFyZSBub3QgY29uc2lzdGVudCBhYm91dCB3aGF0IHNjcm9sbExlZnQgbWVhbnMgaW4gUlRMLiBGb3IgdGhpcyBtZXRob2RcbiAgICogbGVmdCBhbmQgcmlnaHQgYWx3YXlzIHJlZmVyIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlIG9mIHRoZSBzY3JvbGxpbmcgY29udGFpbmVyIGlycmVzcGVjdGl2ZVxuICAgKiBvZiB0aGUgbGF5b3V0IGRpcmVjdGlvbi4gc3RhcnQgYW5kIGVuZCByZWZlciB0byBsZWZ0IGFuZCByaWdodCBpbiBhbiBMVFIgY29udGV4dCBhbmQgdmljZS12ZXJzYVxuICAgKiBpbiBhbiBSVEwgY29udGV4dC5cbiAgICogQHBhcmFtIHNjcm9sbGFibGUgZWxlbWVudFxuICAgKiBAcGFyYW0gY3VzdG9tT3B0aW9ucyBzcGVjaWZpZWQgdGhlIG9mZnNldHMgdG8gc2Nyb2xsIHRvLlxuICAgKi9cbiAgc2Nyb2xsVG8oc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgY3VzdG9tT3B0aW9uczogU21vb3RoU2Nyb2xsVG9PcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtKSkge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLl9nZXRFbGVtZW50KHNjcm9sbGFibGUpO1xuICAgICAgY29uc3QgaXNSdGwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgY29uc3QgcnRsU2Nyb2xsQXhpc1R5cGUgPSBnZXRSdGxTY3JvbGxBeGlzVHlwZSgpO1xuXG4gICAgICBjb25zdCBvcHRpb25zOiBTbW9vdGhTY3JvbGxUb09wdGlvbnMgPSB7XG4gICAgICAgIC4uLih0aGlzLl9kZWZhdWx0T3B0aW9ucyBhcyBfV2l0aG91dDxfQm90dG9tICYgX1RvcD4pLFxuICAgICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgICAuLi4oe1xuICAgICAgICAgIC8vIFJld3JpdGUgc3RhcnQgJiBlbmQgb2Zmc2V0cyBhcyByaWdodCBvciBsZWZ0IG9mZnNldHMuXG4gICAgICAgICAgbGVmdDogY3VzdG9tT3B0aW9ucy5sZWZ0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLmVuZCA6IGN1c3RvbU9wdGlvbnMuc3RhcnQpIDogY3VzdG9tT3B0aW9ucy5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBjdXN0b21PcHRpb25zLnJpZ2h0ID09IG51bGwgPyAoaXNSdGwgPyBjdXN0b21PcHRpb25zLnN0YXJ0IDogY3VzdG9tT3B0aW9ucy5lbmQpIDogY3VzdG9tT3B0aW9ucy5yaWdodFxuICAgICAgICB9IGFzIF9XaXRob3V0PF9Cb3R0b20gJiBfVG9wPilcbiAgICAgIH07XG5cbiAgICAgIC8vIFJld3JpdGUgdGhlIGJvdHRvbSBvZmZzZXQgYXMgYSB0b3Agb2Zmc2V0LlxuICAgICAgaWYgKG9wdGlvbnMuYm90dG9tICE9IG51bGwpIHtcbiAgICAgICAgKG9wdGlvbnMgYXMgX1dpdGhvdXQ8X0JvdHRvbT4gJiBfVG9wKS50b3AgPSBlbC5zY3JvbGxIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQgLSBvcHRpb25zLmJvdHRvbTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV3cml0ZSB0aGUgcmlnaHQgb2Zmc2V0IGFzIGEgbGVmdCBvZmZzZXQuXG4gICAgICBpZiAoaXNSdGwgJiYgcnRsU2Nyb2xsQXhpc1R5cGUgIT09IFJ0bFNjcm9sbEF4aXNUeXBlLk5PUk1BTCkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAob3B0aW9ucyBhcyBfV2l0aG91dDxfTGVmdD4gJiBfUmlnaHQpLnJpZ2h0ID0gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIG9wdGlvbnMubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydGxTY3JvbGxBeGlzVHlwZSA9PT0gUnRsU2Nyb2xsQXhpc1R5cGUuSU5WRVJURUQpIHtcbiAgICAgICAgICBvcHRpb25zLmxlZnQgPSBvcHRpb25zLnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHJ0bFNjcm9sbEF4aXNUeXBlID09PSBSdGxTY3JvbGxBeGlzVHlwZS5ORUdBVEVEKSB7XG4gICAgICAgICAgb3B0aW9ucy5sZWZ0ID0gb3B0aW9ucy5yaWdodCA/IC1vcHRpb25zLnJpZ2h0IDogb3B0aW9ucy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgIChvcHRpb25zIGFzIF9XaXRob3V0PF9SaWdodD4gJiBfTGVmdCkubGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSBvcHRpb25zLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYXBwbHlTY3JvbGxUb09wdGlvbnMoZWwsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIHRvIGVsZW1lbnQgYnkgcmVmZXJlbmNlIG9yIHNlbGVjdG9yXG4gICAqL1xuICBzY3JvbGxUb0VsZW1lbnQoc2Nyb2xsYWJsZTogU21vb3RoU2Nyb2xsRWxlbWVudCwgdGFyZ2V0OiBTbW9vdGhTY3JvbGxFbGVtZW50LCBjdXN0b21PcHRpb25zOiBTbW9vdGhTY3JvbGxPcHRpb25zICYgX1RvcCAmIF9MZWZ0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2Nyb2xsYWJsZUVsID0gdGhpcy5fZ2V0RWxlbWVudChzY3JvbGxhYmxlKTtcbiAgICBjb25zdCB0YXJnZXRFbCA9IHRoaXMuX2dldEVsZW1lbnQodGFyZ2V0LCBzY3JvbGxhYmxlRWwpO1xuICAgIGNvbnN0IG9wdGlvbnM6IFNtb290aFNjcm9sbFRvT3B0aW9ucyA9IHtcbiAgICAgIC4uLmN1c3RvbU9wdGlvbnMsXG4gICAgICAuLi57XG4gICAgICAgIGxlZnQ6IHRhcmdldEVsLm9mZnNldExlZnQgKyAoY3VzdG9tT3B0aW9ucy5sZWZ0IHx8IDApLFxuICAgICAgICB0b3A6IHRhcmdldEVsLm9mZnNldFRvcCArIChjdXN0b21PcHRpb25zLnRvcCB8fCAwKVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRhcmdldEVsID8gdGhpcy5zY3JvbGxUbyhzY3JvbGxhYmxlRWwsIG9wdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbn1cbiJdfQ==