import { __decorate, __metadata, __param } from 'tslib';
import { Input, Optional, NgZone, Output, Directive, NgModule } from '@angular/core';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { NgScrollbar, NgScrollbarModule } from 'ngx-scrollbar';
import { Subject, Subscription, Observable } from 'rxjs';
import { tap, map, distinctUntilChanged, filter } from 'rxjs/operators';

// Uncomment the following line in development mode
// import { NgScrollbar } from '../../src/public-api';
class ReachedFunctions {
    static reachedTop(offset, e) {
        return ReachedFunctions.reached(-e.target.scrollTop, 0, offset);
    }
    static reachedBottom(offset, e) {
        return ReachedFunctions.reached(e.target.scrollTop + e.target.clientHeight, e.target.scrollHeight, offset);
    }
    static reachedStart(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(e.target.scrollLeft, 0, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
            }
            return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
        }
        return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
    }
    static reachedEnd(offset, e, direction, rtlScrollAxisType) {
        if (direction === 'rtl') {
            if (rtlScrollAxisType === 1 /* NEGATED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft - e.target.clientWidth), e.target.scrollWidth, offset);
            }
            if (rtlScrollAxisType === 2 /* INVERTED */) {
                return ReachedFunctions.reached(-(e.target.scrollLeft + e.target.clientWidth), e.target.scrollWidth, offset);
            }
            return ReachedFunctions.reached(-e.target.scrollLeft, 0, offset);
        }
        return ReachedFunctions.reached(e.target.scrollLeft + e.target.clientWidth, e.target.scrollWidth, offset);
    }
    static reached(currPosition, targetPosition, offset) {
        return currPosition >= targetPosition - offset;
    }
}
class ScrollReached {
    constructor(scrollbar, zone) {
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** offset: Reached offset value in px */
        this.offset = 0;
        /**
         * Stream that emits scroll event when `NgScrollbar.scrolled` is initialized.
         *
         * **NOTE:** This subject is used to hold the place of `NgScrollbar.scrolled` when it's not initialized yet
         */
        this.scrollEvent = new Subject();
        /** subscription: Scrolled event subscription, used to unsubscribe from the event on destroy */
        this.subscription = Subscription.EMPTY;
        /** A stream used to assign the reached output */
        this.reachedEvent = new Observable((subscriber) => this.scrollReached().subscribe(_ => Promise.resolve().then(() => this.zone.run(() => subscriber.next(_)))));
        if (!scrollbar) {
            throw new Error('[NgScrollbarReached Directive]: Host element must be an NgScrollbar component.');
        }
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    scrollReached() {
        // current event
        let currEvent;
        return this.scrollEvent.pipe(tap((e) => currEvent = e), 
        // Check if it scroll has reached
        map((e) => this.reached(this.offset, e)), 
        // Distinct until reached value has changed
        distinctUntilChanged(), 
        // Emit only if reached is true
        filter((reached) => reached), 
        // Return scroll event
        map(() => currEvent));
    }
}
__decorate([
    Input('reachedOffset'),
    __metadata("design:type", Object)
], ScrollReached.prototype, "offset", void 0);
let VerticalScrollReached = class VerticalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.verticalScrolled.subscribe(this.scrollEvent);
    }
};
VerticalScrollReached = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], VerticalScrollReached);
let HorizontalScrollReached = class HorizontalScrollReached extends ScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
    }
    ngOnInit() {
        this.subscription = this.scrollbar.horizontalScrolled.subscribe(this.scrollEvent);
    }
};
HorizontalScrollReached = __decorate([
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], HorizontalScrollReached);
let NgScrollbarReachedTop = class NgScrollbarReachedTop extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the top */
        this.reachedTop = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the top (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedTop(offset, e);
    }
};
NgScrollbarReachedTop.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedTop.prototype, "reachedTop", void 0);
NgScrollbarReachedTop = __decorate([
    Directive({
        selector: '[reachedTop], [reached-top]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], NgScrollbarReachedTop);
let NgScrollbarReachedBottom = class NgScrollbarReachedBottom extends VerticalScrollReached {
    constructor(scrollbar, zone) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        /** Stream that emits when scroll has reached the bottom */
        this.reachedBottom = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the bottom (vertically)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedBottom(offset, e);
    }
};
NgScrollbarReachedBottom.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedBottom.prototype, "reachedBottom", void 0);
NgScrollbarReachedBottom = __decorate([
    Directive({
        selector: '[reachedBottom], [reached-bottom]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone])
], NgScrollbarReachedBottom);
let NgScrollbarReachedStart = class NgScrollbarReachedStart extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the start */
        this.reachedStart = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the start (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedStart(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
};
NgScrollbarReachedStart.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedStart.prototype, "reachedStart", void 0);
NgScrollbarReachedStart = __decorate([
    Directive({
        selector: '[reachedStart], [reached-start]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
], NgScrollbarReachedStart);
let NgScrollbarReachedEnd = class NgScrollbarReachedEnd extends HorizontalScrollReached {
    constructor(scrollbar, zone, dir) {
        super(scrollbar, zone);
        this.scrollbar = scrollbar;
        this.zone = zone;
        this.dir = dir;
        /** Stream that emits when scroll has reached the end */
        this.reachedEnd = this.reachedEvent;
    }
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * Check if scroll has reached the end (horizontally)
     * @param offset Scroll offset
     * @param e Scroll event
     */
    reached(offset, e) {
        return ReachedFunctions.reachedEnd(offset, e, this.dir.value, this.scrollbar.manager.rtlScrollAxisType);
    }
};
NgScrollbarReachedEnd.ctorParameters = () => [
    { type: NgScrollbar, decorators: [{ type: Optional }] },
    { type: NgZone },
    { type: Directionality }
];
__decorate([
    Output(),
    __metadata("design:type", Observable)
], NgScrollbarReachedEnd.prototype, "reachedEnd", void 0);
NgScrollbarReachedEnd = __decorate([
    Directive({
        selector: '[reachedEnd], [reached-end]',
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [NgScrollbar, NgZone, Directionality])
], NgScrollbarReachedEnd);

let NgScrollbarReachedModule = class NgScrollbarReachedModule {
};
NgScrollbarReachedModule = __decorate([
    NgModule({
        imports: [
            NgScrollbarModule,
            BidiModule
        ],
        declarations: [
            NgScrollbarReachedTop,
            NgScrollbarReachedBottom,
            NgScrollbarReachedStart,
            NgScrollbarReachedEnd
        ],
        exports: [
            NgScrollbarReachedTop,
            NgScrollbarReachedBottom,
            NgScrollbarReachedStart,
            NgScrollbarReachedEnd
        ]
    })
], NgScrollbarReachedModule);

/**
 * Generated bundle index. Do not edit.
 */

export { NgScrollbarReachedBottom, NgScrollbarReachedEnd, NgScrollbarReachedModule, NgScrollbarReachedStart, NgScrollbarReachedTop };
//# sourceMappingURL=ngx-scrollbar-reached-event.js.map
