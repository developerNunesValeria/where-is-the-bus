import { __decorate, __param, __metadata, __assign, __read, __values, __extends } from 'tslib';
import { ElementRef, Inject, Directive, InjectionToken, Optional, ɵɵdefineInjectable, ɵɵinject, Injectable, EventEmitter, NgZone, ChangeDetectorRef, Input, Output, ViewChild, ContentChild, Component, ChangeDetectionStrategy, RendererStyleFlags2, Renderer2, NgModule } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';
import { Directionality, BidiModule } from '@angular/cdk/bidi';
import { PortalModule } from '@angular/cdk/portal';
import { getRtlScrollAxisType, Platform, PlatformModule } from '@angular/cdk/platform';
import { SmoothScrollManager, SmoothScrollModule } from 'ngx-scrollbar/smooth-scroll';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { Observable, fromEvent, merge, Subject, BehaviorSubject, Subscription, of, from, EMPTY, animationFrameScheduler, asyncScheduler } from 'rxjs';
import { tap, map, takeUntil, switchMap, pluck, pairwise, filter, auditTime, debounceTime, distinctUntilChanged, catchError, mergeMap } from 'rxjs/operators';

function preventSelection(doc) {
    return tap(function () {
        doc.onselectstart = function () { return false; };
    });
}
function enableSelection(doc) {
    return tap(function () {
        doc.onselectstart = null;
    });
}
function stopPropagation() {
    return tap(function (e) { return e.stopPropagation(); });
}
/**
 * Check if pointer is within scrollbar bounds
 */
function isWithinBounds(e, rect) {
    return (e.clientX >= rect.left &&
        e.clientX <= rect.left + rect.width &&
        e.clientY >= rect.top &&
        e.clientY <= rect.top + rect.height);
}

var ScrollViewport = /** @class */ (function () {
    function ScrollViewport(viewPort, document) {
        this.viewPort = viewPort;
        this.document = document;
        this.nativeElement = viewPort.nativeElement;
    }
    Object.defineProperty(ScrollViewport.prototype, "clientHeight", {
        // Get viewport size, clientHeight or clientWidth
        get: function () {
            return this.nativeElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "clientWidth", {
        get: function () {
            return this.nativeElement.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollHeight", {
        get: function () {
            return this.nativeElement.scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollWidth", {
        get: function () {
            return this.nativeElement.scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollTop", {
        // Get viewport scroll offset, scrollTop or scrollLeft
        get: function () {
            return this.nativeElement.scrollTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollLeft", {
        get: function () {
            return this.nativeElement.scrollLeft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollMaxX", {
        // Get the available scrollable size
        get: function () {
            return this.scrollWidth - this.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "scrollMaxY", {
        get: function () {
            return this.scrollHeight - this.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollViewport.prototype, "contentHeight", {
        get: function () {
            return this.contentWrapperElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activate viewport pointer events such as 'hovered' and 'clicked' events
     */
    ScrollViewport.prototype.activatePointerEvents = function (propagate, destroyed) {
        var _this = this;
        this.hovered = new Observable(function (subscriber) {
            // Stream that emits when pointer is moved over the viewport (used to set the hovered state)
            var mouseMoveStream = fromEvent(_this.nativeElement, 'mousemove', { passive: true });
            var mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation());
            // Stream that emits when pointer leaves the viewport (used to remove the hovered state)
            var mouseLeave = fromEvent(_this.nativeElement, 'mouseleave').pipe(map(function () { return false; }));
            merge(mouseMove, mouseLeave).pipe(tap(function (e) { return subscriber.next(e); }), takeUntil(destroyed)).subscribe();
        });
        this.clicked = new Observable(function (subscriber) {
            var mouseDown = fromEvent(_this.nativeElement, 'mousedown', { passive: true }).pipe(tap(function (e) { return subscriber.next(e); }));
            var mouseUp = fromEvent(_this.nativeElement, 'mouseup', { passive: true }).pipe(tap(function () { return subscriber.next(false); }));
            mouseDown.pipe(switchMap(function () { return mouseUp; }), takeUntil(destroyed)).subscribe();
        });
    };
    /**
     * Set this directive as a non-functional wrapper, called when a custom viewport is used
     */
    ScrollViewport.prototype.setAsWrapper = function () {
        // In this case the default viewport and the default content wrapper will act as a mask
        this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';
        if (this.nativeElement.firstElementChild) {
            this.nativeElement.firstElementChild.className = 'ng-scroll-layer';
        }
    };
    /**
     * Set this directive as  the viewport, called when no custom viewport is used
     */
    ScrollViewport.prototype.setAsViewport = function (customClassName) {
        this.nativeElement.className = "ng-native-scrollbar-hider ng-scroll-viewport " + customClassName;
        // Check if the custom viewport has only one child and set it as the content wrapper
        if (this.nativeElement.firstElementChild) {
            this.contentWrapperElement = this.nativeElement.firstElementChild;
            this.contentWrapperElement.classList.add('ng-scroll-content');
        }
    };
    /**
     * Scroll viewport vertically
     */
    ScrollViewport.prototype.scrollYTo = function (value) {
        this.nativeElement.scrollTop = value;
    };
    /**
     * Scroll viewport horizontally
     */
    ScrollViewport.prototype.scrollXTo = function (value) {
        this.nativeElement.scrollLeft = value;
    };
    ScrollViewport.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    ScrollViewport = __decorate([
        Directive({
            selector: '[scrollViewport]'
        }),
        __param(1, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [ElementRef, Object])
    ], ScrollViewport);
    return ScrollViewport;
}());

var NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');

var defaultOptions = {
    viewClass: '',
    trackClass: '',
    thumbClass: '',
    track: 'vertical',
    appearance: 'compact',
    visibility: 'native',
    position: 'native',
    pointerEventsMethod: 'viewport',
    trackClickScrollDuration: 300,
    minThumbSize: 20,
    windowResizeDebounce: 0,
    sensorDebounce: 0,
    scrollAuditTime: 0,
    viewportPropagateMouseMove: true
};
var ScrollbarManager = /** @class */ (function () {
    function ScrollbarManager(options) {
        this.globalOptions = options ? __assign(__assign({}, defaultOptions), options) : defaultOptions;
        this.rtlScrollAxisType = getRtlScrollAxisType();
    }
    ScrollbarManager.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_SCROLLBAR_OPTIONS,] }] }
    ]; };
    ScrollbarManager.ɵprov = ɵɵdefineInjectable({ factory: function ScrollbarManager_Factory() { return new ScrollbarManager(ɵɵinject(NG_SCROLLBAR_OPTIONS, 8)); }, token: ScrollbarManager, providedIn: "root" });
    ScrollbarManager = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(0, Optional()), __param(0, Inject(NG_SCROLLBAR_OPTIONS)),
        __metadata("design:paramtypes", [Object])
    ], ScrollbarManager);
    return ScrollbarManager;
}());

var NgScrollbar = /** @class */ (function () {
    function NgScrollbar(el, zone, changeDetectorRef, dir, smoothScroll, manager) {
        this.el = el;
        this.zone = zone;
        this.changeDetectorRef = changeDetectorRef;
        this.dir = dir;
        this.smoothScroll = smoothScroll;
        this.manager = manager;
        this._disabled = false;
        this._sensorDisabled = this.manager.globalOptions.sensorDisabled;
        this._pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled;
        this._viewportPropagateMouseMove = this.manager.globalOptions.viewportPropagateMouseMove;
        /** A class forwarded to scrollable viewport element */
        this.viewClass = this.manager.globalOptions.viewClass;
        /** A class forwarded to the scrollbar track element */
        this.trackClass = this.manager.globalOptions.trackClass;
        /** A class forwarded to the scrollbar thumb element */
        this.thumbClass = this.manager.globalOptions.thumbClass;
        /** Minimum scrollbar thumb size */
        this.minThumbSize = this.manager.globalOptions.minThumbSize;
        /** The duration which the scrolling takes to reach its target when scrollbar rail is clicked */
        this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;
        /**
         * Sets the pointer events method
         * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)
         * Use scrollbar pointer events to handle dragging and track click
         */
        this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod;
        /**
         * Sets the supported scroll track of the viewport, there are 3 options:
         *
         * - `vertical` Use both vertical and horizontal scrollbar
         * - `horizontal` Use both vertical and horizontal scrollbar
         * - `all` Use both vertical and horizontal scrollbar
         */
        this.track = this.manager.globalOptions.track;
        /**
         * When to show the scrollbar, and there are 3 options:
         *
         * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar
         * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering
         * - `always` Scrollbars are always shown even if the viewport is not scrollable
         */
        this.visibility = this.manager.globalOptions.visibility;
        /**
         *  Sets the appearance of the scrollbar, there are 2 options:
         *
         * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.
         * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.
         */
        this.appearance = this.manager.globalOptions.appearance;
        /**
         * Sets the position of each scrollbar, there are 4 options:
         *
         * - `native` (Default) Use the default position like in native scrollbar.
         * - `invertY` Inverts vertical scrollbar position
         * - `invertX` Inverts Horizontal scrollbar position
         * - `invertAll` Inverts both scrollbar positions
         */
        this.position = this.manager.globalOptions.position;
        /** Debounce interval for detecting changes via ResizeObserver */
        this.sensorDebounce = this.manager.globalOptions.sensorDebounce;
        /** Scroll Audit Time */
        this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime;
        /** Steam that emits when scrollbar is updated */
        this.updated = new EventEmitter();
        /** Set of attributes added on the scrollbar wrapper */
        this.state = {};
        /** Stream that destroys components' observables */
        this.destroyed = new Subject();
    }
    Object.defineProperty(NgScrollbar.prototype, "disabled", {
        /** Disable custom scrollbar and switch back to native scrollbar */
        get: function () {
            return this._disabled;
        },
        set: function (disabled) {
            this._disabled = coerceBooleanProperty(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgScrollbar.prototype, "sensorDisabled", {
        /** Whether ResizeObserver is disabled */
        get: function () {
            return this._sensorDisabled;
        },
        set: function (disabled) {
            this._sensorDisabled = coerceBooleanProperty(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgScrollbar.prototype, "pointerEventsDisabled", {
        /** A flag used to enable/disable the scrollbar thumb dragged event */
        get: function () {
            return this._pointerEventsDisabled;
        },
        set: function (disabled) {
            this._pointerEventsDisabled = coerceBooleanProperty(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgScrollbar.prototype, "viewportPropagateMouseMove", {
        /** Enable viewport mousemove event propagation (only when pointerEventsMethod="viewport") */
        get: function () {
            return this._viewportPropagateMouseMove;
        },
        set: function (disabled) {
            this._viewportPropagateMouseMove = coerceBooleanProperty(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgScrollbar.prototype, "nativeElement", {
        get: function () {
            return this.el.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update local state with each change detection
     */
    NgScrollbar.prototype.updateState = function () {
        var verticalUsed = false;
        var horizontalUsed = false;
        var isVerticallyScrollable = false;
        var isHorizontallyScrollable = false;
        // Check if vertical scrollbar should be displayed
        if (this.track === 'all' || this.track === 'vertical') {
            isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;
            verticalUsed = this.visibility === 'always' || isVerticallyScrollable;
        }
        // Check if horizontal scrollbar should be displayed
        if (this.track === 'all' || this.track === 'horizontal') {
            isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;
            horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;
        }
        // Update inner wrapper attributes
        this._updateState({
            position: this.position,
            track: this.track,
            appearance: this.appearance,
            visibility: this.visibility,
            deactivated: this.disabled,
            dir: this.dir.value,
            pointerEventsMethod: this.pointerEventsMethod,
            verticalUsed: verticalUsed,
            horizontalUsed: horizontalUsed,
            isVerticallyScrollable: isVerticallyScrollable,
            isHorizontallyScrollable: isHorizontallyScrollable
        });
    };
    NgScrollbar.prototype._updateState = function (state) {
        this.state = __assign(__assign({}, this.state), state);
        this.changeDetectorRef.detectChanges();
    };
    NgScrollbar.prototype.getScrolledByDirection = function (property) {
        var event;
        return this.scrolled.pipe(tap(function (e) { return event = e; }), pluck('target', property), pairwise(), filter(function (_a) {
            var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
            return prev !== curr;
        }), map(function () { return event; }));
    };
    /**
     * Set hovered state if a scrollbar is being hovered
     */
    NgScrollbar.prototype.setHovered = function (hovered) {
        var _this = this;
        this.zone.run(function () { return _this._updateState(__assign({}, hovered)); });
    };
    /**
     * Set dragging state if a scrollbar is being dragged
     */
    NgScrollbar.prototype.setDragging = function (dragging) {
        var _this = this;
        this.zone.run(function () { return _this._updateState(__assign({}, dragging)); });
    };
    /**
     * Set clicked state if a scrollbar track is being click
     */
    NgScrollbar.prototype.setClicked = function (scrollbarClicked) {
        var _this = this;
        this.zone.run(function () { return _this._updateState({ scrollbarClicked: scrollbarClicked }); });
    };
    NgScrollbar.prototype.ngOnInit = function () {
        var _this = this;
        // Set the viewport based on user choice
        this.zone.runOutsideAngular(function () {
            if (_this.customViewPort) {
                _this.viewport = _this.customViewPort;
                _this.defaultViewPort.setAsWrapper();
            }
            else {
                _this.viewport = _this.defaultViewPort;
            }
            // Activate the selected viewport
            _this.viewport.setAsViewport(_this.viewClass);
            var scrollStream = fromEvent(_this.viewport.nativeElement, 'scroll', { passive: true });
            // Throttle scroll event if 'scrollAuditTime' is set
            scrollStream = _this.scrollAuditTime ? scrollStream.pipe(auditTime(_this.scrollAuditTime)) : scrollStream;
            // Initialize scroll streams
            _this.scrolled = new Observable(function (subscriber) {
                return scrollStream.pipe(takeUntil(_this.destroyed)).subscribe(subscriber);
            });
            _this.verticalScrolled = _this.getScrolledByDirection('scrollTop');
            _this.horizontalScrolled = _this.getScrolledByDirection('scrollLeft');
        });
    };
    NgScrollbar.prototype.ngAfterViewChecked = function () {
        this.updateState();
    };
    NgScrollbar.prototype.ngOnDestroy = function () {
        this.destroyed.next();
        this.destroyed.complete();
    };
    /**
     * Update local state and the internal scrollbar controls
     */
    NgScrollbar.prototype.update = function () {
        if (!this.state.horizontalUsed) {
            // Auto-height: Set component height to content height
            this.nativeElement.style.height = this.viewport.contentHeight + "px";
        }
        this.updated.next();
        this.changeDetectorRef.detectChanges();
    };
    /**
     * Smooth scroll functions
     */
    NgScrollbar.prototype.scrollTo = function (options) {
        return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);
    };
    /**
     * Scroll to element by reference or selector
     */
    NgScrollbar.prototype.scrollToElement = function (target, options) {
        return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);
    };
    NgScrollbar.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: ChangeDetectorRef },
        { type: Directionality },
        { type: SmoothScrollManager },
        { type: ScrollbarManager }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], NgScrollbar.prototype, "disabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], NgScrollbar.prototype, "sensorDisabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], NgScrollbar.prototype, "pointerEventsDisabled", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], NgScrollbar.prototype, "viewportPropagateMouseMove", null);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "viewClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "trackClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "thumbClass", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NgScrollbar.prototype, "minThumbSize", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NgScrollbar.prototype, "trackClickScrollDuration", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "pointerEventsMethod", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "track", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "visibility", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "appearance", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], NgScrollbar.prototype, "position", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NgScrollbar.prototype, "sensorDebounce", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Number)
    ], NgScrollbar.prototype, "scrollAuditTime", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], NgScrollbar.prototype, "updated", void 0);
    __decorate([
        ViewChild(ScrollViewport, { static: true }),
        __metadata("design:type", ScrollViewport)
    ], NgScrollbar.prototype, "defaultViewPort", void 0);
    __decorate([
        ContentChild(ScrollViewport, { static: true }),
        __metadata("design:type", ScrollViewport)
    ], NgScrollbar.prototype, "customViewPort", void 0);
    NgScrollbar = __decorate([
        Component({
            selector: 'ng-scrollbar',
            exportAs: 'ngScrollbar',
            template: "<div class=\"ng-scrollbar-wrapper\" [ngAttr]=\"state\">\n  <div class=\"ng-scroll-viewport-wrapper\"\n       (resizeSensor)=\"update()\"\n       [sensorDebounce]=\"sensorDebounce\"\n       [sensorDisabled]=\"sensorDisabled\">\n    <div scrollViewport\n         hideNativeScrollbar>\n      <div>\n        <ng-content></ng-content>\n      </div>\n    </div>\n  </div>\n  <ng-container *ngIf=\"!disabled\">\n    <scrollbar-x *ngIf=\"state.horizontalUsed\"\n                 [attr.scrollable]=\"state.isHorizontallyScrollable\"\n                 [attr.fit]=\"state.verticalUsed\">\n    </scrollbar-x>\n    <scrollbar-y *ngIf=\"state.verticalUsed\"\n                 [attr.scrollable]=\"state.isVerticallyScrollable\"\n                 [attr.fit]=\"state.horizontalUsed\">\n    </scrollbar-y>\n  </ng-container>\n</div>\n\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            host: { '[class.ng-scrollbar]': 'true' },
            styles: ["::ng-deep .ng-scrollbar-measure{left:0;overflow:scroll;position:fixed;top:-9999px;scrollbar-width:none;-ms-overflow-style:none}::ng-deep .ng-scrollbar-measure::-webkit-scrollbar{display:none}:host{--scrollbar-border-radius:7px;--scrollbar-padding:4px;--scrollbar-track-color:transparent;--scrollbar-thumb-color:rgba(0, 0, 0, 0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-size:5px;--scrollbar-hover-size:var(--scrollbar-size);--scrollbar-thumb-transition:height ease-out 150ms,width ease-out 150ms;--scrollbar-track-transition:height ease-out 150ms,width ease-out 150ms;display:block;position:relative;height:100%;max-height:100%;max-width:100%}:host>.ng-scrollbar-wrapper{--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding) * 2);--vertical-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2)}:host>.ng-scrollbar-wrapper[verticalDragging=true],:host>.ng-scrollbar-wrapper[verticalHovered=true]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[horizontalDragging=true],:host>.ng-scrollbar-wrapper[horizontalHovered=true]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding) * 2);cursor:default}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:var(--scrollbar-total-size);right:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-left:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{left:0;right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-right:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:0;bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-bottom:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar]>.ng-scroll-viewport-wrapper{top:var(--scrollbar-total-size);bottom:0}:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{padding-top:var(--scrollbar-total-size)}:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{scrollbar-width:none;-ms-overflow-style:none}:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport::-webkit-scrollbar,:host>.ng-scrollbar-wrapper[deactivated=false]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport::-webkit-scrollbar{display:none}:host>.ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-native-scrollbar-hider,:host>.ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{bottom:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-native-scrollbar-hider,:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{left:0;right:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-native-scrollbar-hider,:host>.ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl]>.ng-scroll-viewport-wrapper>.ng-native-scrollbar-hider{right:0;left:var(--native-scrollbar-size)}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]>.scrollbar-control{opacity:0;transition-property:opacity;transition-duration:.4s;transition-delay:.8s}:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:active>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:focus>.scrollbar-control,:host>.ng-scrollbar-wrapper[deactivated=false][visibility=hover]:hover>.scrollbar-control{opacity:1;transition-duration:.4s;transition-delay:0s}:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-x:auto;overflow-y:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow-y:auto;overflow-x:hidden}:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,:host>.ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{overflow:auto}.ng-scroll-viewport-wrapper{overflow:hidden}.ng-scroll-viewport{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}::ng-deep .ng-scroll-content{position:relative!important;display:inline-block;min-width:100%}.ng-scroll-layer,.ng-scroll-viewport-wrapper,.ng-scrollbar-wrapper,::ng-deep .ng-scroll-viewport{position:absolute;left:0;right:0;top:0;bottom:0}", "::ng-deep .ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*>::ng-deep.ng-scroll-viewport,::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control{position:absolute;display:flex;justify-content:center;align-items:center;transition:var(--scrollbar-track-transition)}::ng-deep .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}::ng-deep .ng-scrollbar-track{height:100%;width:100%;z-index:1;border-radius:var(--scrollbar-border-radius);background-color:var(--scrollbar-track-color);overflow:hidden;transition:var(--scrollbar-track-transition);cursor:default}::ng-deep .ng-scrollbar-thumb{box-sizing:border-box;position:relative;border-radius:inherit;background-color:var(--scrollbar-thumb-color);transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}"]
        }),
        __metadata("design:paramtypes", [ElementRef,
            NgZone,
            ChangeDetectorRef,
            Directionality,
            SmoothScrollManager,
            ScrollbarManager])
    ], NgScrollbar);
    return NgScrollbar;
}());

var NativeScrollbarSizeFactory = /** @class */ (function () {
    function NativeScrollbarSizeFactory(document, manager, platform) {
        var _this = this;
        this.document = document;
        this.manager = manager;
        this.platform = platform;
        this._scrollbarSize = new BehaviorSubject(this.getNativeScrollbarSize());
        this.scrollbarSize = this._scrollbarSize.asObservable();
        // Calculate native scrollbar size on window resize event, because the size changes if use zoomed in/out
        if (platform.isBrowser) {
            fromEvent(this.document.defaultView, 'resize', { passive: true }).pipe(debounceTime(this.manager.globalOptions.windowResizeDebounce), map(function () { return _this.getNativeScrollbarSize(); }), distinctUntilChanged(), tap(function (size) { return _this._scrollbarSize.next(size); })).subscribe();
        }
    }
    /**
     * Get native scrollbar size
     */
    NativeScrollbarSizeFactory.prototype.getNativeScrollbarSize = function () {
        // Avoid executing browser code in server side rendering
        if (!this.platform.isBrowser) {
            return 0;
        }
        // Hide iOS browsers native scrollbar
        if (this.platform.IOS) {
            return 6;
        }
        var box = this.document.createElement('div');
        box.className = 'ng-scrollbar-measure';
        this.document.body.appendChild(box);
        var size = box.getBoundingClientRect().right;
        this.document.body.removeChild(box);
        return size;
    };
    NativeScrollbarSizeFactory.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ScrollbarManager },
        { type: Platform }
    ]; };
    NativeScrollbarSizeFactory.ɵprov = ɵɵdefineInjectable({ factory: function NativeScrollbarSizeFactory_Factory() { return new NativeScrollbarSizeFactory(ɵɵinject(DOCUMENT), ɵɵinject(ScrollbarManager), ɵɵinject(Platform)); }, token: NativeScrollbarSizeFactory, providedIn: "root" });
    NativeScrollbarSizeFactory = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(0, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [Object, ScrollbarManager,
            Platform])
    ], NativeScrollbarSizeFactory);
    return NativeScrollbarSizeFactory;
}());

var HideNativeScrollbar = /** @class */ (function () {
    function HideNativeScrollbar(el, renderer, hideNativeScrollbar) {
        var _this = this;
        this.renderer = renderer;
        this.hideNativeScrollbar = hideNativeScrollbar;
        this._subscriber = Subscription.EMPTY;
        this._subscriber = hideNativeScrollbar.scrollbarSize.subscribe(function (size) {
            _this.renderer.setStyle(el.nativeElement, '--native-scrollbar-size', "-" + size + "px", RendererStyleFlags2.DashCase);
        });
    }
    HideNativeScrollbar.prototype.ngOnDestroy = function () {
        this._subscriber.unsubscribe();
    };
    HideNativeScrollbar.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NativeScrollbarSizeFactory }
    ]; };
    HideNativeScrollbar = __decorate([
        Directive({
            selector: '[hideNativeScrollbar]'
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            NativeScrollbarSizeFactory])
    ], HideNativeScrollbar);
    return HideNativeScrollbar;
}());

var NgAttr = /** @class */ (function () {
    function NgAttr(el) {
        this.el = el;
    }
    Object.defineProperty(NgAttr.prototype, "ngAttr", {
        set: function (attrs) {
            var e_1, _a;
            try {
                for (var _b = __values(Object.entries(attrs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                    this.el.nativeElement.setAttribute(key, value);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        },
        enumerable: true,
        configurable: true
    });
    NgAttr.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], NgAttr.prototype, "ngAttr", null);
    NgAttr = __decorate([
        Directive({ selector: '[ngAttr]' }),
        __metadata("design:paramtypes", [ElementRef])
    ], NgAttr);
    return NgAttr;
}());

/**
 * Factory that initialize the ResizeObserver if available in the browser
 * Otherwise, it lazy-loads the ResizeObserver polyfill
 */
var ResizeObserverFactory = /** @class */ (function () {
    function ResizeObserverFactory(document, platform) {
        this.resizeObserverSource = new BehaviorSubject(null);
        this.resizeObserverLoader = this.resizeObserverSource.asObservable();
        if (platform.isBrowser) {
            var resizeObserverApi = document.defaultView.ResizeObserver
                ? of(document.defaultView.ResizeObserver)
                : from(import('@juggle/resize-observer')).pipe(map(function (module) { return module.ResizeObserver; }), catchError(function (e) {
                    console.log('Unable to load ResizeObserver polyfill', e);
                    return EMPTY;
                }));
            this.resizeObserverSource.next(resizeObserverApi);
        }
    }
    ResizeObserverFactory.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Platform }
    ]; };
    ResizeObserverFactory.ɵprov = ɵɵdefineInjectable({ factory: function ResizeObserverFactory_Factory() { return new ResizeObserverFactory(ɵɵinject(DOCUMENT), ɵɵinject(Platform)); }, token: ResizeObserverFactory, providedIn: "root" });
    ResizeObserverFactory = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(0, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [Object, Platform])
    ], ResizeObserverFactory);
    return ResizeObserverFactory;
}());
var ResizeSensor = /** @class */ (function () {
    function ResizeSensor(zone, platform, resizeObserverFactory, scrollbar) {
        this.zone = zone;
        this.platform = platform;
        this.resizeObserverFactory = resizeObserverFactory;
        this.scrollbar = scrollbar;
        this._disabled = false;
        this._subscription = null;
        this.resizeSensor = new EventEmitter();
        if (!scrollbar) {
            throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');
        }
    }
    Object.defineProperty(ResizeSensor.prototype, "debounce", {
        /** Debounce interval for emitting the changes. */
        get: function () {
            return this._debounce;
        },
        set: function (value) {
            this._debounce = coerceNumberProperty(value);
            this._subscribe();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResizeSensor.prototype, "disabled", {
        /** Whether ResizeObserver is disabled. */
        get: function () {
            return this._disabled;
        },
        set: function (value) {
            this._disabled = coerceBooleanProperty(value);
            this._disabled ? this._unsubscribe() : this._subscribe();
        },
        enumerable: true,
        configurable: true
    });
    ResizeSensor.prototype.ngAfterContentInit = function () {
        if (!this._subscription && !this._disabled) {
            this._subscribe();
        }
    };
    ResizeSensor.prototype.ngOnDestroy = function () {
        this._unsubscribe();
    };
    ResizeSensor.prototype._createObserver = function (ResizeObserver) {
        var _this = this;
        return new Observable(function (observer) {
            _this._resizeObserver = new ResizeObserver(function () { return observer.next(); });
            _this._resizeObserver.observe(_this.scrollbar.viewport.nativeElement);
            if (_this.scrollbar.viewport.contentWrapperElement) {
                _this._resizeObserver.observe(_this.scrollbar.viewport.contentWrapperElement);
            }
        });
    };
    ResizeSensor.prototype._subscribe = function () {
        var _this = this;
        this._unsubscribe();
        if (this.platform.isBrowser) {
            this.zone.runOutsideAngular(function () {
                _this._subscription = _this.resizeObserverFactory.resizeObserverLoader.pipe(switchMap(function (moduleObservable) { return moduleObservable; }), switchMap(function (ResizeObserver) {
                    if (ResizeObserver) {
                        var stream = _this._createObserver(ResizeObserver);
                        return _this.debounce ? stream.pipe(debounceTime(_this._debounce)) : stream;
                    }
                    else {
                        return EMPTY;
                    }
                })).subscribe(function () { return _this.resizeSensor.emit(); });
            });
        }
    };
    ResizeSensor.prototype._unsubscribe = function () {
        if (this._resizeObserver) {
            this._resizeObserver.disconnect();
        }
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    };
    ResizeSensor.ctorParameters = function () { return [
        { type: NgZone },
        { type: Platform },
        { type: ResizeObserverFactory },
        { type: NgScrollbar }
    ]; };
    __decorate([
        Input('sensorDebounce'),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], ResizeSensor.prototype, "debounce", null);
    __decorate([
        Input('sensorDisabled'),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], ResizeSensor.prototype, "disabled", null);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ResizeSensor.prototype, "resizeSensor", void 0);
    ResizeSensor = __decorate([
        Directive({ selector: '[resizeSensor]' }),
        __metadata("design:paramtypes", [NgZone,
            Platform,
            ResizeObserverFactory,
            NgScrollbar])
    ], ResizeSensor);
    return ResizeSensor;
}());

var TrackAdapter = /** @class */ (function () {
    function TrackAdapter(cmp, trackElement, document) {
        this.cmp = cmp;
        this.trackElement = trackElement;
        this.document = document;
    }
    Object.defineProperty(TrackAdapter.prototype, "clicked", {
        // Stream that emits when the track element is clicked
        get: function () {
            var mouseDown = fromEvent(this.trackElement, 'mousedown', { passive: true }).pipe(stopPropagation(), preventSelection(this.document));
            var mouseup = fromEvent(this.document, 'mouseup', { passive: true }).pipe(stopPropagation(), enableSelection(this.document), switchMap(function () { return EMPTY; }));
            return merge(mouseDown, mouseup);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TrackAdapter.prototype, "hovered", {
        // Stream that emits when the track element is hovered
        get: function () {
            var mouseEnter = fromEvent(this.trackElement, 'mouseenter', { passive: true }).pipe(stopPropagation(), map(function () { return true; }));
            var mouseLeave = fromEvent(this.trackElement, 'mouseleave', { passive: true }).pipe(stopPropagation(), map(function () { return false; }));
            return merge(mouseEnter, mouseLeave);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TrackAdapter.prototype, "clientRect", {
        // Get track client rect
        get: function () {
            return this.trackElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Stream that emits when scrollbar track is clicked
     */
    TrackAdapter.prototype.onTrackClicked = function (e, thumbSize, scrollSize) {
        var _this = this;
        return of(e).pipe(pluck(this.pageProperty), 
        // Calculate scrollTo position
        map(function (pageOffset) {
            var clickOffset = pageOffset - _this.offset;
            var offset = clickOffset - (thumbSize / 2);
            var ratio = offset / _this.size;
            return ratio * scrollSize;
        }), 
        // Smooth scroll to position
        tap(function (value) {
            _this.cmp.scrollTo(__assign(__assign({}, _this.mapToScrollToOption(value)), { duration: coerceNumberProperty(_this.cmp.trackClickScrollDuration) }));
        }));
    };
    return TrackAdapter;
}());

var ThumbAdapter = /** @class */ (function () {
    function ThumbAdapter(cmp, thumbElement, document) {
        this.cmp = cmp;
        this.thumbElement = thumbElement;
        this.document = document;
        // Stream that emits dragging state
        this._dragging = new Subject();
        this.dragging = this._dragging.pipe(distinctUntilChanged());
    }
    Object.defineProperty(ThumbAdapter.prototype, "trackMax", {
        get: function () {
            return this.track.size - this.size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbAdapter.prototype, "clientRect", {
        // Get thumb client rect
        get: function () {
            return this.thumbElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbAdapter.prototype, "clicked", {
        // Stream that emits when scrollbar thumb is clicked
        get: function () {
            return fromEvent(this.thumbElement, 'mousedown', { passive: true }).pipe(stopPropagation());
        },
        enumerable: true,
        configurable: true
    });
    // Calculate and update thumb position and size
    ThumbAdapter.prototype.update = function () {
        var _this = this;
        var size = calculateThumbSize(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize);
        var position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);
        animationFrameScheduler.schedule(function () { return _this.updateStyles(_this.handleDirection(position, _this.trackMax), size); });
    };
    /**
     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged
     * This function is called by thumb drag event using viewport or scrollbar pointer events
     */
    ThumbAdapter.prototype.dragged = function (event) {
        var _this = this;
        var trackMaxStart;
        var scrollMaxStart;
        var dragStart = of(event).pipe(preventSelection(this.document), tap(function () {
            // Capture scrollMax and trackMax once
            trackMaxStart = _this.trackMax;
            scrollMaxStart = _this.viewportScrollMax;
            _this.setDragging(true);
        }));
        var dragging = fromEvent(this.document, 'mousemove', { capture: true, passive: true }).pipe(stopPropagation());
        var dragEnd = fromEvent(this.document, 'mouseup', { capture: true }).pipe(stopPropagation(), enableSelection(this.document), tap(function () { return _this.setDragging(false); }));
        return dragStart.pipe(pluck(this.pageProperty), map(function (pageOffset) { return pageOffset - _this.dragStartOffset; }), mergeMap(function (mouseDownOffset) { return dragging.pipe(pluck(_this.clientProperty), 
        // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).
        map(function (mouseOffset) { return mouseOffset - _this.track.offset; }), map(function (offset) { return scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart; }), map(function (position) { return _this.handleDrag(position, scrollMaxStart); }), tap(function (position) { return _this.scrollTo(position); }), takeUntil(dragEnd)); }));
    };
    __decorate([
        Input(),
        __metadata("design:type", TrackAdapter)
    ], ThumbAdapter.prototype, "track", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], ThumbAdapter.prototype, "dragging", void 0);
    return ThumbAdapter;
}());
/**
 * Calculate scrollbar thumb size
 */
function calculateThumbSize(trackSize, contentSize, minThumbSize) {
    var scrollbarRatio = trackSize / contentSize;
    var thumbSize = scrollbarRatio * trackSize;
    return Math.max(~~thumbSize, minThumbSize);
}
/**
 * Calculate scrollbar thumb position
 */
function calculateThumbPosition(scrollPosition, scrollMax, trackMax) {
    return scrollPosition * trackMax / scrollMax;
}

var ThumbXDirective = /** @class */ (function (_super) {
    __extends(ThumbXDirective, _super);
    function ThumbXDirective(cmp, element, document, dir) {
        var _this = _super.call(this, cmp, element.nativeElement, document) || this;
        _this.cmp = cmp;
        _this.element = element;
        _this.document = document;
        _this.dir = dir;
        return _this;
    }
    Object.defineProperty(ThumbXDirective.prototype, "clientProperty", {
        get: function () {
            return 'clientX';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbXDirective.prototype, "pageProperty", {
        get: function () {
            return 'pageX';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbXDirective.prototype, "viewportScrollSize", {
        get: function () {
            return this.cmp.viewport.scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbXDirective.prototype, "viewportScrollOffset", {
        get: function () {
            return this.cmp.viewport.scrollLeft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbXDirective.prototype, "viewportScrollMax", {
        get: function () {
            return this.cmp.viewport.scrollMaxX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbXDirective.prototype, "dragStartOffset", {
        get: function () {
            return this.clientRect.left;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbXDirective.prototype, "size", {
        get: function () {
            return this.thumbElement.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    ThumbXDirective.prototype.updateStyles = function (position, size) {
        this.thumbElement.style.width = size + "px";
        this.thumbElement.style.transform = "translate3d(" + position + "px, 0, 0)";
    };
    ThumbXDirective.prototype.handleDrag = function (position, scrollMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === 1 /* NEGATED */) {
                return position - scrollMax;
            }
            if (this.cmp.manager.rtlScrollAxisType === 2 /* INVERTED */) {
                return scrollMax - position;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {
            //   return position;
            // }
        }
        return position;
    };
    ThumbXDirective.prototype.handleDirection = function (position, trackMax) {
        if (this.dir.value === 'rtl') {
            if (this.cmp.manager.rtlScrollAxisType === 2 /* INVERTED */) {
                return -position;
            }
            if (this.cmp.manager.rtlScrollAxisType === 0 /* NORMAL */) {
                return position - trackMax;
            }
            // Keeping this as a memo
            // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {
            //   return position;
            // }
        }
        return position;
    };
    ThumbXDirective.prototype.setDragging = function (value) {
        this.cmp.setDragging({ horizontalDragging: value });
    };
    ThumbXDirective.prototype.scrollTo = function (position) {
        this.cmp.viewport.scrollXTo(position);
    };
    ThumbXDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Directionality }
    ]; };
    ThumbXDirective = __decorate([
        Directive({ selector: '[scrollbarThumbX]' }),
        __param(2, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [NgScrollbar,
            ElementRef, Object, Directionality])
    ], ThumbXDirective);
    return ThumbXDirective;
}(ThumbAdapter));
var ThumbYDirective = /** @class */ (function (_super) {
    __extends(ThumbYDirective, _super);
    function ThumbYDirective(cmp, element, document) {
        var _this = _super.call(this, cmp, element.nativeElement, document) || this;
        _this.cmp = cmp;
        _this.element = element;
        _this.document = document;
        return _this;
    }
    Object.defineProperty(ThumbYDirective.prototype, "pageProperty", {
        get: function () {
            return 'pageY';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbYDirective.prototype, "viewportScrollSize", {
        get: function () {
            return this.cmp.viewport.scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbYDirective.prototype, "viewportScrollOffset", {
        get: function () {
            return this.cmp.viewport.scrollTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbYDirective.prototype, "viewportScrollMax", {
        get: function () {
            return this.cmp.viewport.scrollMaxY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbYDirective.prototype, "clientProperty", {
        get: function () {
            return 'clientY';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbYDirective.prototype, "dragStartOffset", {
        get: function () {
            return this.clientRect.top;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ThumbYDirective.prototype, "size", {
        get: function () {
            return this.thumbElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    ThumbYDirective.prototype.updateStyles = function (position, size) {
        this.thumbElement.style.height = size + "px";
        this.thumbElement.style.transform = "translate3d(0px, " + position + "px, 0)";
    };
    ThumbYDirective.prototype.handleDrag = function (position) {
        return position;
    };
    ThumbYDirective.prototype.handleDirection = function (position) {
        return position;
    };
    ThumbYDirective.prototype.setDragging = function (value) {
        this.cmp.setDragging({ verticalDragging: value });
    };
    ThumbYDirective.prototype.scrollTo = function (position) {
        this.cmp.viewport.scrollYTo(position);
    };
    ThumbYDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    ThumbYDirective = __decorate([
        Directive({ selector: '[scrollbarThumbY]' }),
        __param(2, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [NgScrollbar,
            ElementRef, Object])
    ], ThumbYDirective);
    return ThumbYDirective;
}(ThumbAdapter));

var TrackXDirective = /** @class */ (function (_super) {
    __extends(TrackXDirective, _super);
    function TrackXDirective(cmp, trackElement, document) {
        var _this = _super.call(this, cmp, trackElement.nativeElement, document) || this;
        _this.cmp = cmp;
        _this.document = document;
        return _this;
    }
    Object.defineProperty(TrackXDirective.prototype, "pageProperty", {
        get: function () {
            return 'pageX';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TrackXDirective.prototype, "offset", {
        get: function () {
            return this.clientRect.left;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TrackXDirective.prototype, "size", {
        get: function () {
            return this.trackElement.clientWidth;
        },
        enumerable: true,
        configurable: true
    });
    TrackXDirective.prototype.mapToScrollToOption = function (value) {
        return { left: value };
    };
    TrackXDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    TrackXDirective = __decorate([
        Directive({ selector: '[scrollbarTrackX]' }),
        __param(2, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [NgScrollbar, ElementRef, Object])
    ], TrackXDirective);
    return TrackXDirective;
}(TrackAdapter));
var TrackYDirective = /** @class */ (function (_super) {
    __extends(TrackYDirective, _super);
    function TrackYDirective(cmp, trackElement, document) {
        var _this = _super.call(this, cmp, trackElement.nativeElement, document) || this;
        _this.cmp = cmp;
        _this.document = document;
        return _this;
    }
    Object.defineProperty(TrackYDirective.prototype, "pageProperty", {
        get: function () {
            return 'pageY';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TrackYDirective.prototype, "offset", {
        get: function () {
            return this.clientRect.top;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TrackYDirective.prototype, "size", {
        get: function () {
            return this.trackElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    TrackYDirective.prototype.mapToScrollToOption = function (value) {
        return { top: value };
    };
    TrackYDirective.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    TrackYDirective = __decorate([
        Directive({ selector: '[scrollbarTrackY]' }),
        __param(2, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [NgScrollbar, ElementRef, Object])
    ], TrackYDirective);
    return TrackYDirective;
}(TrackAdapter));

var Scrollbar = /** @class */ (function () {
    function Scrollbar(cmp, platform, document, zone) {
        this.cmp = cmp;
        this.platform = platform;
        this.document = document;
        this.zone = zone;
        // Stream that emits to unsubscribe from all streams
        this.destroyed = new Subject();
    }
    /**
     * Activate scrollbar pointer events
     */
    Scrollbar.prototype.activatePointerEvents = function () {
        var _this = this;
        // Stream that emits when scrollbar thumb is dragged
        var thumbDragEvent = EMPTY;
        // Stream that emits when scrollbar track is clicked
        var trackClickEvent = EMPTY;
        // Stream that emits when scrollbar track is hovered
        var trackHoveredEvent = EMPTY;
        // Set the method used for the pointer events option
        if (this.cmp.pointerEventsMethod === 'viewport') {
            // Pointer events using the viewport
            this.viewportTrackClicked = new Subject();
            this.viewportThumbClicked = new Subject();
            // Activate the pointer events of the viewport directive
            this.cmp.viewport.activatePointerEvents(this.cmp.viewportPropagateMouseMove, this.destroyed);
            // Set streams
            thumbDragEvent = this.viewportThumbClicked;
            trackClickEvent = this.viewportTrackClicked;
            trackHoveredEvent = this.cmp.viewport.hovered.pipe(
            // Check if track is hovered
            map(function (e) { return isWithinBounds(e, _this.track.clientRect); }), distinctUntilChanged(), 
            // Enable / disable text selection
            tap(function (hovered) { return _this.document.onselectstart = hovered ? function () { return false; } : null; }));
            this.cmp.viewport.clicked.pipe(tap(function (e) {
                if (e) {
                    if (isWithinBounds(e, _this.thumb.clientRect)) {
                        _this.viewportThumbClicked.next(e);
                    }
                    else if (isWithinBounds(e, _this.track.clientRect)) {
                        _this.cmp.setClicked(true);
                        _this.viewportTrackClicked.next(e);
                    }
                }
                else {
                    _this.cmp.setClicked(false);
                }
            }), takeUntil(this.destroyed)).subscribe();
        }
        else {
            // Pointer events method is using 'scrollbar'
            thumbDragEvent = this.thumb.clicked;
            trackClickEvent = this.track.clicked;
            trackHoveredEvent = this.track.hovered;
        }
        return merge(
        // Activate scrollbar hovered event
        trackHoveredEvent.pipe(tap(function (e) { return _this.setHovered(e); })), 
        // Activate scrollbar thumb drag event
        thumbDragEvent.pipe(switchMap(function (e) { return _this.thumb.dragged(e); })), 
        // Activate scrollbar track click event
        trackClickEvent.pipe(switchMap(function (e) { return _this.track.onTrackClicked(e, _this.thumb.size, _this.viewportScrollSize); })));
    };
    Scrollbar.prototype.ngOnInit = function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            // Activate pointer events on Desktop only
            if (!(_this.platform.IOS || _this.platform.ANDROID) && !_this.cmp.pointerEventsDisabled) {
                _this.activatePointerEvents().pipe(takeUntil(_this.destroyed)).subscribe();
            }
            // Stream that emits when host component is updated
            var updated = _this.cmp.updated.pipe(tap(function () { return _this.onUpdated(); }));
            // Update scrollbar thumb when viewport is scrolled and when scrollbar component is updated
            merge(_this.cmp.scrolled, updated).pipe(tap(function () { return _this.thumb.update(); }), takeUntil(_this.destroyed)).subscribe();
            // Initialize scrollbar
            asyncScheduler.schedule(function () { return _this.thumb.update(); }, 100);
        });
    };
    Scrollbar.prototype.ngOnDestroy = function () {
        this.destroyed.next();
        this.destroyed.complete();
        // Clean up viewport streams if used
        if (this.viewportThumbClicked && this.viewportTrackClicked) {
            this.viewportTrackClicked.complete();
            this.viewportThumbClicked.complete();
        }
    };
    return Scrollbar;
}());

var ScrollbarY = /** @class */ (function (_super) {
    __extends(ScrollbarY, _super);
    function ScrollbarY(cmp, platform, document, zone) {
        var _this = _super.call(this, cmp, platform, document, zone) || this;
        _this.cmp = cmp;
        _this.platform = platform;
        _this.document = document;
        _this.zone = zone;
        return _this;
    }
    Object.defineProperty(ScrollbarY.prototype, "viewportScrollSize", {
        get: function () {
            return this.cmp.viewport.scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    ScrollbarY.prototype.setHovered = function (value) {
        this.cmp.setHovered({ verticalHovered: value });
    };
    ScrollbarY.prototype.onUpdated = function () {
    };
    ScrollbarY.ctorParameters = function () { return [
        { type: NgScrollbar },
        { type: Platform },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone }
    ]; };
    __decorate([
        ViewChild(TrackYDirective, { static: true }),
        __metadata("design:type", TrackYDirective)
    ], ScrollbarY.prototype, "track", void 0);
    __decorate([
        ViewChild(ThumbYDirective, { static: true }),
        __metadata("design:type", ThumbYDirective)
    ], ScrollbarY.prototype, "thumb", void 0);
    ScrollbarY = __decorate([
        Component({
            selector: 'scrollbar-y',
            host: { '[class.scrollbar-control]': 'true' },
            changeDetection: ChangeDetectionStrategy.OnPush,
            template: "\n    <div scrollbarTrackY class=\"ng-scrollbar-track {{cmp.trackClass}}\">\n      <div scrollbarThumbY [track]=\"track\" class=\"ng-scrollbar-thumb {{cmp.thumbClass}}\"></div>\n    </div>\n  ",
            styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{width:var(--vertical-scrollbar-size);height:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}::ng-deep .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{top:0;bottom:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{right:0;left:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control{left:unset;right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true]{top:var(--scrollbar-total-size);bottom:0}"]
        }),
        __param(2, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [NgScrollbar, Platform, Object, NgZone])
    ], ScrollbarY);
    return ScrollbarY;
}(Scrollbar));
var ScrollbarX = /** @class */ (function (_super) {
    __extends(ScrollbarX, _super);
    function ScrollbarX(el, cmp, platform, document, zone) {
        var _this = _super.call(this, cmp, platform, document, zone) || this;
        _this.el = el;
        _this.cmp = cmp;
        _this.platform = platform;
        _this.document = document;
        _this.zone = zone;
        return _this;
    }
    Object.defineProperty(ScrollbarX.prototype, "viewportScrollSize", {
        get: function () {
            return this.cmp.viewport.scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ScrollbarX.prototype, "thickness", {
        get: function () {
            return this.el.nativeElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    ScrollbarX.prototype.setHovered = function (value) {
        this.cmp.setHovered({ horizontalHovered: value });
    };
    ScrollbarX.prototype.onUpdated = function () {
        // Auto-height: Set root component height to content height
        this.cmp.nativeElement.style.height = this.cmp.appearance === 'standard'
            ? this.cmp.viewport.contentHeight + this.thickness + "px"
            : this.cmp.viewport.contentHeight + "px";
    };
    ScrollbarX.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgScrollbar },
        { type: Platform },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone }
    ]; };
    __decorate([
        ViewChild(TrackXDirective, { static: true }),
        __metadata("design:type", TrackXDirective)
    ], ScrollbarX.prototype, "track", void 0);
    __decorate([
        ViewChild(ThumbXDirective, { static: true }),
        __metadata("design:type", ThumbXDirective)
    ], ScrollbarX.prototype, "thumb", void 0);
    ScrollbarX = __decorate([
        Component({
            selector: 'scrollbar-x',
            host: { '[class.scrollbar-control]': 'true' },
            changeDetection: ChangeDetectionStrategy.OnPush,
            template: "\n    <div scrollbarTrackX class=\"ng-scrollbar-track {{cmp.trackClass}}\">\n      <div scrollbarThumbX [track]=\"track\" class=\"ng-scrollbar-thumb {{cmp.thumbClass}}\"></div>\n    </div>\n  ",
            styles: ["::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding) * 2)}::ng-deep .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{width:0;height:100%}::ng-deep .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,::ng-deep .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}::ng-deep .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{left:0;right:0;bottom:0;top:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control,::ng-deep .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control{top:0;bottom:unset}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],::ng-deep .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{right:var(--scrollbar-total-size);left:0}"]
        }),
        __param(3, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [ElementRef,
            NgScrollbar,
            Platform, Object, NgZone])
    ], ScrollbarX);
    return ScrollbarX;
}(Scrollbar));

var NgScrollbarModule = /** @class */ (function () {
    function NgScrollbarModule() {
    }
    NgScrollbarModule_1 = NgScrollbarModule;
    NgScrollbarModule.withConfig = function (options) {
        return {
            ngModule: NgScrollbarModule_1,
            providers: [
                { provide: NG_SCROLLBAR_OPTIONS, useValue: options }
            ]
        };
    };
    var NgScrollbarModule_1;
    NgScrollbarModule = NgScrollbarModule_1 = __decorate([
        NgModule({
            imports: [
                CommonModule,
                BidiModule,
                PortalModule,
                PlatformModule,
                SmoothScrollModule
            ],
            declarations: [
                NgScrollbar,
                ScrollViewport,
                HideNativeScrollbar,
                NgAttr,
                ResizeSensor,
                ThumbYDirective,
                ThumbXDirective,
                TrackXDirective,
                TrackYDirective,
                ScrollbarY,
                ScrollbarX
            ],
            exports: [
                NgScrollbar,
                ScrollViewport
            ]
        })
    ], NgScrollbarModule);
    return NgScrollbarModule;
}());

/*
 * Public API Surface of ngx-scrollbar
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarModule, ScrollViewport, ScrollbarManager, HideNativeScrollbar as ɵa, NativeScrollbarSizeFactory as ɵb, NgAttr as ɵc, ResizeObserverFactory as ɵd, ResizeSensor as ɵe, ThumbXDirective as ɵf, ThumbYDirective as ɵg, ThumbAdapter as ɵh, TrackXDirective as ɵi, TrackYDirective as ɵj, TrackAdapter as ɵk, ScrollbarY as ɵl, ScrollbarX as ɵm, Scrollbar as ɵn };
//# sourceMappingURL=ngx-scrollbar.js.map
